labeled=TRUE
scopeOfBioReplication="restricted"
scopeOfTechReplication="expanded"
interference=TRUE
equalFeatureVar=TRUE
#########################################################
.fit.model<-function(contrast.matrix,data,labeled,scopeOfBioReplication,scopeOfTechReplication,interference,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup){#
	nrepeats=3#
	## label-free : use only light intensity, need to change contrast.matrix without Group0	#
	if(!labeled){#
		## use only light#
		data2<-subset(data,LABEL=="L")#
		data2$GROUP<-factor(data2$GROUP)#
		data2$SUBJECT<-factor(data2$SUBJECT)#
#
		# when single subject, there is no need to distinguish case-control and time course; fixed subject or random subject, and no need to have GXF since there is not enough degree of freedom, hence no separatation of interference	#
		if (singleSubject){#
			if(!TechReplicate){#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP , data = data2)#
			}else{#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + GROUP:FEATURE , data = data2)#
			}#
			## make equal variance for feature#
			if(!equalFeatureVar){#
				fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
			}#
#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", paste(origGroup[GroupComparisonAgreement$positionMiss],collapse=", "), " are missing completely.")#
#
					out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
		} ## singleSubject is TRUE#
#
		if (!singleSubject){#
		# when subject is fixed, it is ok using lm function. When we use lm, model with nested or crossed samples have the same results. In the future, if we want to have sample quantification. We need to separate the cases of nested or crossed samples.#
#
		#===========#
		# (1) Subject:F; case-control/time course#
		# since it's fixed effect model, the results of nested model and crossed model are the same#
		# but when there is unequal subject, the SE is slightly different#
		# also no missing patterns (GXF, G, S) will stop the test#
		#==========	#
			if (scopeOfBioReplication=="restricted"){#
				# case-control#
				if (!repeated){	#
					if(interference){#
     					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data2)#
					}else{#
	  					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP, data = data2)#
					}#
				}else{	## time-course#
					if(interference){#
      					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data2)#
      					#fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + SUBJECT:GROUP + GROUP + FEATURE:GROUP , data = data2)#
					}else{#
	  					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP, data = data2)#
	  					#fit.full<-lm(ABUNDANCE ~ FEATURE + SUBJECT + SUBJECT:GROUP + GROUP, data = data2)#
#
					}#
				}#
	     		## make equal variance for feature#
	     		if(!equalFeatureVar){#
	     			fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
	     		}#
				## get parameter from model before all comparison#
				fixedPara<-.getParameterFixed(fit.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
						out<-.estimableFixedRandom(fixedPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)#
				} # end loop for contrast#
#
			} ## bioRep is restricted#
	#===========#
	# (2) Subject:R; #
	# since it's mixed effect model, the results of nested model and crossed model are not the same#
	# df of nested and crossed are not the same as well.#
	# also missing patterns (GXF) will stop the test, but (G, S) will not#
	#==========	#
			if (scopeOfBioReplication=="expanded"){#
#
				# case-control#
				if (!repeated){#
					if(interference){#
						if(!MissGroupByFeature){#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1-1)#
      					}else{  ## MissGroupByFeature==TRUE#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP, data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1-1)#
      					}#
					}else{ ## interference==FALSE#
	  					fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP, data = data2)#
	  					temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  					temp1<-xtabs(~GROUP,data=temp)#
      					df.full<-sum(temp1-1)#
					}#
				}else{  ##time-course#
					if(interference){#
						if(!MissGroupByFeature){#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + FEATURE:GROUP , data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1[-1]-1)#
      					}else{ ## MissGroupByFeature==TRUE#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +   (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP, data = data2)#
     						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1[-1]-1)#
      					}#
					}else{  ## interference==FALSE#
	  					fit.full<-lmer(ABUNDANCE ~ FEATURE +   (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP, data = data2)#
	  					temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  					temp1<-xtabs(~GROUP,data=temp)#
      					df.full<-sum(temp1[-1]-1)#
					}#
				}#
	     		## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)#
				} # end loop for contrast#
			}## bio rep is expanded#
#
		}## singleSub=FALSE#
#
	} ## label -free	#
	if(labeled){	#
	# when single subject, there is no need to distinguish case-control and time course; fixed subject or random subject, and no need to have GXF RXF since there is not enough degree of freedom, hence no separatation of interference	#
		if (singleSubject){#
			message(paste("*** ",unique(data$PROTEIN)," has single subject per condition. Only restricted scope of conclusion is possible."))#
			if(TechReplicate){#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + RUN + GROUP:FEATURE + RUN:FEATURE, data = data)#
			}else{#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + RUN, data = data)#
			}#
	     	## make equal variance for feature#
	     	if(!equalFeatureVar){#
	   			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
	   		}#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
#
		} ## singleSub is True#
#
		if (!singleSubject){#
		##########################	#
		# (1) Subject: F, Run: F#
		##########################	#
#
			if(scopeOfBioReplication=="restricted" & scopeOfTechReplication=="restricted"){#
				## (1.1) case-control#
				if (!repeated){#
					if(interference){#
						fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
					}else{#
						fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + RUN, data = data)#
					}#
				}else{  ## (1.2) time-course#
					if(interference){#
						fit.full<-lm(ABUNDANCE ~ FEATURE  +  SUBJECT_NESTED + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
					}else{#
						fit.full<-lm(ABUNDANCE ~ FEATURE  +  SUBJECT_NESTED  + GROUP + RUN, data = data)#
					}#
				}	#
		     	## make equal variance for feature#
	     		if(!equalFeatureVar){#
	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
	     		}#
				## get parameter from model#
				fixedPara<-.getParameterFixed(fit.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(fixedPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			} ## fSfR#
		##########################	#
		# (2) Subject: R, Run: F#
		##########################	#
#
			if(scopeOfBioReplication=="expanded"&scopeOfTechReplication=="restricted"){#
				## (2.1) case-control#
				if (!repeated){#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN, data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)		#
						}#
					}else{ ##interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN, data = data)#
						# calculate DF of SUBJECT_NESTED#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-1]-1)#
					}#
				}else{  ## (2.2) time-course#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN, data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)	#
						}#
					}else{  ##interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + RUN, data = data)#
						# calculate DF of SUBJECT:GROUP#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-c(1,2)]-1)#
					}	#
				}#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}	#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			}	#rSfR#
		##########################	#
		# (3) Subject: F, Run: R#
		# only SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP can work for model fitting#
		# therefore, there is no need to separate case-control and time course#
		# however, when there is unequal subject, we need to fit additive model of removing SUBJECT by GROUP#
		##########################	#
#
			if(scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
				## (3.1) equal subject per group#
				if (!UnequalSubject){#
					if(interference){#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)$df.residual#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
						}#
					}else{  ## interference#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN), data = data)#
						df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
					}#
				}else{ ## (3.2) unequal subject per group#
					if(interference){		#
						if(!MissGroupByFeature & !MissRunByFeature){#
#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)$df.residual#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL  + GROUP + (1|RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT  + RUN, data = data)$df.residual#
						}			#
					}else{ ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL  + GROUP + (1|RUN), data = data)#
						df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
					}#
				}	#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			} #fSrR	#
		##########################	#
		# (4) Subject: R, Run: R#
		##########################	#
#
			if(scopeOfBioReplication=="expanded" & scopeOfTechReplication=="expanded"){#
				## (4.1) case-control#
				if (!repeated){#
					if(interference){#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED)  + GROUP + (1|RUN), data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}#
					}else{ ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + (1|RUN), data = data)#
						# calculate DF of SUBJECT_NESTED#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-1]-1)#
					}#
				}else{  ## (4.2) time-course#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN), data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}#
					}else{  ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + (1|RUN), data = data)#
						# calculate DF of SUBJECT:GROUP#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-c(1,2)]-1)#
					}#
				}	#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison	#
			} #rSrR		#
		} ## singleSub is FALSE#
	}## label-based#
	if(class(fit.full)=="lm"){  ### lm model#
		finalresid<-fit.full$residuals#
		finalfitted<-fit.full$fitted.values#
	}else{   ### lmer model#
		finalresid<-resid(fit.full)#
		finalfitted<-fitted(fit.full)#
	}#
	finalout<-list(result=allout,valueresid=finalresid, valuefitted=finalfitted)	#
#
	return(finalout)#
}
repeated=FALSE
data$PROTEIN<-factor(data$PROTEIN)	#
out<-NULL#
outsummary<-NULL#
dataafterfit<-NULL
unique(data$PROTEIN)
i=1
sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]
head(sub)
unique(sub$PROTEIN)
sub<-sub[!is.na(sub$ABUNDANCE),]
sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)
.countMultiRun<-function(data){#
	standardFeature<-unique(data[data$RUN==unique(data$RUN[1]),"FEATURE"]) ## if some feature are missing for this spedific run, it could be error. that is why we need balanced design.#
#
	## get overlapped feature ID#
	countdiff = tapply (data$FEATURE, data$RUN, function ( x ) length(intersect(unique(x),standardFeature)) ) #
#
	return(countdiff)#
}#
#
##############################################
# check if measurements are missing for entire group#
# if yes, length of group and length of contrast won't agree#
##############################################
#
.chechGroupComparisonAgreement<-function(sub1,contrast.matrix){#
	tempSub<-as.numeric(as.character(unique(sub1[,c("GROUP")])))#
	positionMiss<-setdiff(seq(1,length(contrast.matrix)),tempSub)#
	contrast.matrix.sub1<-contrast.matrix[tempSub]#
	# either one of the groups for the comparison of interest is not present #
#
	return(list(sign=length(setdiff(contrast.matrix[tempSub],0))<2,positionMiss=positionMiss))#
}#
##############################################
# check repeated (case-control? or time-course?)#
##############################################
#
.checkRepeated<-function(data){#
	data.light<-data[data$LABEL=="L",]	#
	subjectByGroup<-table(data.light$SUBJECT_ORIGINAL, data.light$GROUP_ORIGINAL)#
	subjectAppearances<-apply(subjectByGroup, 1, function(x) sum(x>0))#
	crossedIndicator<-any(subjectAppearances > 1)#
	return(crossedIndicator)#
}#
#
##############################################
# check single subject for both case-control and time-course?#
##############################################
#
.checkSingleSubject<- function(data){#
	temp<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	temp$GROUP_ORIGINAL<-factor(temp$GROUP_ORIGINAL)#
	temp1<-xtabs(~GROUP_ORIGINAL,data=temp)#
	singleSubject<-all(temp1=="1")#
	return(singleSubject)	#
}#
#
##############################################
# check .checkSingleFeature#
##############################################
#
.checkSingleFeature<- function(data){#
	sigleFeature<-length(unique(data$FEATURE))<2#
	return(sigleFeature)	#
}#
#
##############################################
# check .checkTechReplicate#
##############################################
#
.checkTechReplicate<- function(data){#
#
	data.light<-data[data$LABEL=="L",]#
	temp<-unique(data.light[,c("SUBJECT_NESTED","RUN")])#
	temp$SUBJECT_NESTED<-factor(temp$SUBJECT_NESTED)#
	temp1<-xtabs(~SUBJECT_NESTED,data=temp)#
	TechReplicate<-all(temp1!="1")#
	return(TechReplicate)	#
}#
##############################################
# check .checkRunByFeature#
##############################################
# it might not be right#
.checkRunbyFeature<-function(data){#
	data.light<-data[data$LABEL=="L",]	#
	RunByFeature<-table(data.light$RUN, data.light$FEATURE)#
	emptyRow <- apply(RunByFeature,1, sum)#
	noRunFeature <- any(emptyRow == 0)#
	return(noRunFeature)	#
}#
##############################################
# check .checkMissGroupByFeature#
##############################################
.checkMissGroupByFeature<-function(data){#
	temp<-unique(data[,c("GROUP","FEATURE")])#
	temp1<-xtabs(~GROUP,data=temp)#
	return(any(temp1!=temp1[1]))#
}#
##############################################
# check .checkMissRunByFeature#
##############################################
#
.checkMissRunByFeature<-function(data){#
	##temp<-unique(data[,c("RUN","FEATURE")])#
	temp<-unique(data[data$LABEL=="L",c("RUN","FEATURE")])#
	temp1<-xtabs(~RUN,data=temp)#
	#return(any(temp1!=temp1[1]))#
	return(any(temp1!=length(unique(data$FEATURE))))#
}#
##############################################
# check .checkMissFeature for label-free missingness#
##############################################
.checkMissFeature<-function(data){#
	dataByPeptide <- tapply(as.numeric(data$ABUNDANCE), list(data$FEATURE, data$GROUP_ORIGINAL), function(x) sum(x > 0, na.rm = TRUE))#
	missPeptideInd <- apply(dataByPeptide, 1, function(x) any(x == 0 | is.na(x)))#
	missingPeptides <- names(missPeptideInd)[missPeptideInd == TRUE]#
#
	return(missingPeptides)#
}#
##############################################
# check .checkUnequalSubject#
##############################################
#
.checkUnequalSubject<-function(data){#
#
	#temp<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	temp<-unique(data[data$LABEL=="L",c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	temp1<-xtabs(~GROUP_ORIGINAL,data=temp)#
	return(any(temp1!=temp1[1]))#
}
singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
temp
remove.interaction=FALSE
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
temp
library(lme4)
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
temp
###############################
## featureSelection#
## (1) remove noisy feature#
## (2) rank the feature#
## (3) decision rule: minimize standard error#
.featureSelection1<-function(work,lambda,eta, address){#
	featureSelection<-data.frame(unique(work[,c("PROTEIN","PEPTIDE","FEATURE")]),perFeatureVariance=0,perProteinVariance=0,rank=NA,weights=NA,PRSS=NA,Decision="keep")#
featureSelection$Decision<-as.vector(featureSelection$Decision)#
#
	l<-subset(work,LABEL=="L")#
#
	#=======================	#
	##  generate per-feature weight#
#
	for (i in 1:nlevels(l$PROTEIN)){#
		sub<-subset(l,PROTEIN==levels(l$PROTEIN)[i])	#
		sub<-within(sub,c(PEPTIDE<-factor(PEPTIDE),FEATURE<-factor(FEATURE)))#
#
		# the sort of featue is based on sorting peptide and transition#
		# it is the same as it is in feature selection and work#
		# ABUNDANCE~FEATURE+SUBJECT_NESTED is the same as ABUNDANCE~GROUP+FEATURE+SUBJECT_NESTED#
		# validated by SAS and R for per-feature variance#
#
		# v10: with S(G) and not divide # of feature#
		if (nlevels(sub$FEATURE)>1){#
			contrasts(sub$FEATURE) = contr.sum(length(unique(sub$FEATURE)))#
			fitSub<-lm(ABUNDANCE~GROUP+SUBJECT_NESTED+FEATURE,sub)#
			featureSelection$perProteinVariance[featureSelection$PROTEIN==levels(l$PROTEIN)[i]]<-summary(fitSub)$sigma^2#
#
			# since NA is removed from residual#
			sub$res<-sub$ABUNDANCE#
			sub$res[!is.na(sub$ABUNDANCE)]<-fitSub$residuals#
#
			featureSelection$perFeatureVariance[featureSelection$PROTEIN==levels(l$PROTEIN)[i]]<-as.numeric(tapply(sub$res,sub[,c("FEATURE")], function(x) var(x,na.rm=TRUE)))#
#
		}#
#
		if (nlevels(sub$FEATURE)==1){#
			contrasts(sub$FEATURE) = contr.sum(length(unique(sub$FEATURE)))      #
			fitSub<-lm(ABUNDANCE~GROUP,sub)#
			featureSelection$perProteinVariance[featureSelection$PROTEIN==levels(l$PROTEIN)[i]]<-summary(fitSub)$sigma^2#
			featureSelection$perFeatureVariance[featureSelection$PROTEIN==levels(l$PROTEIN)[i]]<-summary(fitSub)$sigma^2#
		}#
#
		print(paste(i, 'out of ', nlevels(l$PROTEIN), 'proteins are done for computing the weight.', sep=' '))#
#
	}    #End of the for loop over the proteins#
#
	# up-to-here: run COV: add per-feature weights#
#
	varCutoff<-min(c(quantile(featureSelection$perFeatureVariance,0.25,na.rm=TRUE),0.4))#
#
	# add missingness per feature#
#
	temp<-tapply(l$ABUNDANCE,l[,"FEATURE"],function(x) (1-mean(is.na(x),na.rm=TRUE)))#
	temp1<-data.frame(FEATURE=names(temp),MissScore=as.numeric(temp))#
	temp1$FEATURE<-factor(temp1$FEATURE,levels=unique(featureSelection$FEATURE))#
	temp1<-temp1[with(temp1,order(FEATURE)),]#
	featureSelection$MissScore<-temp1$MissScore#
#
	# amount of penalty on missingness#
#
	temp<-tapply(l[,"ABUNDANCE"],l[,"FEATURE"],function(x) mean(is.na(x),na.rm=TRUE))#
#
	missPenalty<-ifelse(length(which(temp>0.5))>min(100,0.5*length(temp)),2,1)#
#
	if(missPenalty==1){#
		missPenalty<-ifelse(length(which(temp>0.5))>0.25*length(temp),1,0)#
	}#
## 20140514 : temporary ignore identificatino score.#
#	if(IdentificationScore==TRUE){#
#		temp<-unique(l[,c("PROTEIN","FEATURE","RUN","IDENTIFICATIONSCORE")])#
#
#		# v13: select the worst score (the largest m_score) of a peptide across runs#
#
#		temp1<-tapply(temp$IDENTIFICATIONSCORE,temp[,c("FEATURE")],function(x) min(x,na.rm=TRUE))#
#		temp2<-data.frame(FEATURE=names(temp1),IdScore=as.numeric(temp1))#
#
#		temp2$FEATURE<-factor(temp2$FEATURE,levels=unique(featureSelection$FEATURE))#
#		temp2<-temp2[with(temp2,order(FEATURE)),]#
#		featureSelection$IdScore<-temp2$IdScore#
#
#		#featureSelection$weights<-ifelse((featureSelection$perProteinVariance/featureSelection$perFeatureVariance*featureSelection$IdScore)>3,3,(featureSelection$perProteinVariance/featureSelection$perFeatureVariance*featureSelection$IdScore))#
#
#		featureSelection$weights<-featureSelection$perProteinVariance/ifelse(featureSelection$perFeatureVariance/(featureSelection$IdScore*featureSelection$MissScore^missPenalty)<varCutoff,varCutoff,featureSelection$perFeatureVariance/(featureSelection$IdScore*featureSelection$MissScore^missPenalty))#
#
#	}else{#
#
		featureSelection$weights<-featureSelection$perProteinVariance/ifelse(featureSelection$perFeatureVariance/featureSelection$MissScore^missPenalty<varCutoff,varCutoff,featureSelection$perFeatureVariance/featureSelection$MissScore^missPenalty)#
#
#	}#
#
	# force all the single feature protein has weights = 1#
	temp1<-unique(l[,c("PROTEIN","FEATURE")])#
	temp2<-xtabs(~PROTEIN,temp1)#
	featureSelection[featureSelection$PROTEIN%in%names(temp2)[temp2==1],"weights"]<-1#
	# #=======================	#
	## (2.1) rank the feature #
	## based on perFeatureVariance#
	featureSelection <- featureSelection[order(featureSelection$PROTEIN),]#
#
	featureSelection[,"rank"]<-unlist(tapply(-featureSelection$weights,featureSelection[,c("PROTEIN")],function(x) rank(x,ties.method = c("min"))))#
#
	# #=======================	#
	## (2.2) save featureSelection results#
#
	#write.csv(featureSelection,file=paste(address,"FeatureSelectionTable.csv",sep=""))#
	#save(featureSelection,file=paste(address,"FeatureSelectionTable.RData",sep=""))#
	# #=======================	#
	# #=======================	#
	# # Define PRSS: control based on Beta Feature and PRSS (without L1-penalty)#
	# #=======================	#
	# #=======================	#
	# #=======================	#
#
	# #=======================	#
	## (2.1) different lambda control different Beta_Feature, PRSS is calculate based on the rank of weights#
#
	temp1<-data.frame(Lambda=rep(lambda,each=length(featureSelection$FEATURE)),FEATURE=rep(featureSelection$FEATURE,length(lambda)))#
#
	featureSelectionOut<-merge(featureSelection,temp1,by="FEATURE")	#
	featureSelectionOut<-featureSelectionOut[with(featureSelectionOut,order(Lambda,FEATURE)),]#
	#Mike: Don't want the duplicated rows#
	featureSelectionOut <- featureSelectionOut[!duplicated(featureSelectionOut), ] #
#
	featureSelectionOut$PRSSprot<-NA#
	# calculate PRSS#
#
	temp<-featureSelection[,c("FEATURE","weights","rank")]#
	l<-merge(l,temp,by="FEATURE",sort=FALSE)#
#
	for (i in 1:nlevels(l$PROTEIN)){#
		sub<-subset(l,PROTEIN==levels(l$PROTEIN)[i])	#
		sub$FEATURE<-factor(sub$FEATURE)#
#
		if(nlevels(sub$FEATURE)>1){#
		# estimate Beta_Feature#
		# since NA is removed from residuals#
			sub$residual<-sub$ABUNDANCE#
			sub$residual[!is.na(sub$ABUNDANCE)]<-lm(ABUNDANCE~GROUP+SUBJECT_NESTED,data=sub,weights=weights)$residuals	#
#
			X<-model.matrix(~FEATURE,data=sub,contrasts=list(FEATURE="contr.sum"))#
#
			X<-X[,-1]#
			a<-lm(residual~X,data=sub)     #Same as lm(formula = residual ~ FEATURE, data = sub, contrasts = list(FEATURE = "contr.sum"))#
			beta<-c(coef(a)[-1],0-sum(coef(a)[-1],na.rm=TRUE))    #Due to the zero-sum constraint#
			feature.rank<-subset(featureSelection,PROTEIN==levels(l$PROTEIN)[i])$rank#
		}#
#
		if(nlevels(sub$FEATURE)==1){#
			sub$residual<-sub$ABUNDANCE#
			sub$residual[!is.na(sub$ABUNDANCE)]<-lm(ABUNDANCE~GROUP,data=sub,weights=weights)$residuals	#
#
			feature.rank<-1#
		}#
		for (k in 1:length(lambda)){#
			res.L<-lambda[k]#
#
			if(nlevels(sub$FEATURE)>1){#
				update.beta<-sign(beta)*ifelse(abs(beta)-res.L>0,abs(beta)-res.L,0)#
				accept.rank<-sum(update.beta!=0,na.rm=TRUE)#
			}#
#
			if(nlevels(sub$FEATURE)==1){#
				accept.rank<-1#
			}#
#
			# gurantee has one feature#
			if(accept.rank==0){accept.rank<-1}#
#
			# based on the feature.rank and select the number of non-0#
			keep.feature<-levels(sub$FEATURE)[which(feature.rank<=accept.rank)]#
#
			# new dataset with only keep.feature#
			sub.new<-sub[sub$FEATURE%in%keep.feature,]#
			sub.new$FEATURE<-factor(sub.new$FEATURE)#
#
			if(nlevels(sub.new$FEATURE)>1){#
#
				contrasts(sub.new$FEATURE) = contr.sum(length(unique(sub.new$FEATURE)))#
				b<-lm(residual~FEATURE,data=sub.new)#
#
				featureSelectionOut[featureSelectionOut$PROTEIN==levels(l$PROTEIN)[i]&featureSelectionOut$Lambda==res.L,"PRSS"]<-anova(b)$Mean[2]#
#
			}#
#
			if(nlevels(sub.new$FEATURE)=="1"){#
				#featureSelectionOut[featureSelectionOut$PROTEIN==levels(l$PROTEIN)[i]&featureSelectionOut$Lambda==res.L,"PRSS"]<-sum((sub.new$residual-mean(sub.new$residual,na.rm=TRUE))^2,na.rm=TRUE)/(dim(sub.new[!is.na(sub.new$residual),])[1]-1)#
#
				b2 <- lm(residual~1,data=sub.new)#
				featureSelectionOut[featureSelectionOut$PROTEIN==levels(l$PROTEIN)[i]&featureSelectionOut$Lambda==res.L,"PRSS"]<-anova(b2)$Mean[1]#
#
			}#
#
			featureSelectionOut[featureSelectionOut$PROTEIN==levels(l$PROTEIN)[i]&featureSelectionOut$Lambda==res.L,"Decision"][-which(feature.rank<=accept.rank)]<-"remove"#
		}#
#
		print(paste(i, 'out of ', nlevels(l$PROTEIN), 'proteins are done for relarization for every lambda.', sep=' '))#
	}    #End of the for loop of protein#
	featureSelectionOut$PRSSprot<-featureSelectionOut$PRSS#
	write.csv(featureSelectionOut,file=paste(address,"FeatureSelectionOutTable.csv",sep=""))#
	save(featureSelectionOut,file=paste(address,"FeatureSelectionOutTable.RData",sep=""))#
#
	# (1) select the best lambda #(1) allProtein - lambda#
	#bestLambda<-as.numeric(names(sort(tapply(featureSelectionOut$PRSSprot,featureSelectionOut[,c("Lambda")],function(x) mean(x))))[1])#
#
	temp<-tapply(featureSelectionOut$PRSSprot,featureSelectionOut[,c("Lambda")],function(x) median(x,na.rm=TRUE))#
	temp1<-abs(diff(temp))#
	d <- median(abs(diff(lambda)))   #Mike consider the slope since ratio is affected by outliers#
	ratio <- temp1/d #
	#ratio<-temp1/sum(temp1,na.rm=TRUE)#
#
	# criteria: has the smallest descreasing and the absolute cutoff of 0.1#
	#eta<-0.1#
	#eta<-0.2#
	set1<-which(ratio<eta)#
	set2<-which(rank(temp,ties.method="min")==1)[1]#
	sign<-sum(set1%in%ifelse(set2==length(temp),(set2-1),set2),na.rm=TRUE)>0#
#
	if(!sign) bestLambda<-unique(featureSelectionOut$Lambda)[set2]	#
	########Suggestions by Mike#########
	##Not necessary to always choose the second last lambda if there are fluctuations in PRSS###
	if(sign) {#
	# make sure the TRUE is continues	#
		if(all(diff(set1)==1)){#
			bestLambda<-unique(featureSelectionOut$Lambda)[set1[1]]#
		}else{#
			ly <- which(diff(set1)!=1)#
			ly2 <- ly[length(ly)]     #Find the last fluctuation#
			bestLambda<-unique(featureSelectionOut$Lambda)[set1[ly2+1]]#
		}	#
#
	}#
	# (2) select the per-protein lambda#
#
	featureSelectionOut <- featureSelectionOut[order(featureSelectionOut$Lambda, featureSelectionOut$FEATURE, featureSelectionOut$PROTEIN),]#
	temp<-unique(featureSelectionOut[,c("PROTEIN","Lambda","PRSSprot")])#
	temp1<-matrix(temp$PRSSprot,ncol=length(unique(featureSelectionOut$Lambda)))#
	colnames(temp1)<-unique(featureSelectionOut$Lambda)#
	rownames(temp1)<-levels(featureSelectionOut$PROTEIN)#
#
	temp2<-t(apply(temp1,1,function(x) abs(diff(x))))#
#
	d <- median(abs(diff(lambda)))   #Mike consider the slope since ratio is affected by outliers#
#
	ratio<-t(apply(temp2,1,function(x) x/d))#
#
	#ratio<-t(apply(temp2,1,function(x) x/ifelse(sum(x,na.rm=TRUE)==0,1,sum(x,na.rm=TRUE))))#
#
	# criteria: has the smallest descreasing and the absolute cutoff of 0.1#
	#eta<-0.2#
	set1<-apply(ratio,1,function(x) which(x<eta))#
	set2<-apply(temp1,1,function(x) which(rank(x,ties.method="min")==1)[1])#
#
	if(is.matrix(set1)){     #In case set1 is not a list, we force set1 be a list#
		set1 <- as.list(as.data.frame(set1))#
	}#
#
	temp4<-rep(0,dim(ratio)[1])#
#
	for (i in 1:dim(ratio)[1]){#
		sign<-sum(set1[[i]]%in%ifelse(set2[i]==dim(temp1)[2],(set2[i]-1),set2[i]),na.rm=TRUE)>0	#
		if(!sign) temp4[i]<-set2[i]	#
		if(sign) {#
			# make sure the TRUE is continues	#
			if(all(diff(set1[[i]])==1)){#
				temp4[i]<-set1[[i]][1]#
			}else{#
				ly <- which(diff(set1[[i]])!=1)#
				ly2 <- ly[length(ly)]     #Find the last fluctuation#
				temp4[i]<-set1[[i]][ly2+1]#
			}	#
		}#
#
	}#
	perProteinLambda<-data.frame(Protein=levels(featureSelectionOut$PROTEIN),perProtLambda=unique(featureSelectionOut$Lambda)[temp4],perProtPosition=temp4)#
	# generate PRSS plot#
#
	pdf(file=paste(address,"PRSSPlot.pdf",sep=""))#
	colLambda<-ifelse(unique(featureSelectionOut$Lambda)==bestLambda,7,0)#
	borderLambda<-colLambda#
	borderLambda[borderLambda==0]<-1#
	borderLambda[borderLambda!=1]<-2#
	sub<-unique(featureSelectionOut[,c("PRSSprot","Lambda")])#
	boxplot(PRSSprot~Lambda,data=sub,main="All proteins",xlab="Lambda",ylab="PRSS",col=colLambda,border=borderLambda)#
#
	upPRSS<-quantile(sub[,"PRSSprot"],0.90)#
	#upPRSS<-max(sub[,"PRSSprot"], na.rm=TRUE)#
	#upPRSS<-0.2#
#
	for (i in 1:nlevels(featureSelectionOut$PROTEIN)){#
		sub<-featureSelectionOut[featureSelectionOut$PROTEIN==levels(featureSelectionOut$PROTEIN)[i],]#
		numKeep<-tapply(sub$Decision,sub[,"Lambda"],function(x) sum(x=="keep",na.rm=TRUE))#
		temp<-unique(sub[,c("Lambda","PRSSprot")])#
		plot(temp,type="b",xaxt="n",ylim=c(0,upPRSS),ylab="PRSS")#
		coltemp<-rep(1,dim(temp)[1])#
		coltemp[perProteinLambda$perProtPosition[i]]<-2#
		points(temp,pch=19,col=coltemp)#
		axis(1,at=lambda,labels=lambda)#
		axis(3,at=lambda,labels=numKeep)#
		mtext("# of selected features",at=lambda[1],line=2,cex=.7)#
		mtext(levels(featureSelectionOut$PROTEIN)[i],line=2.5,cex=1.2)#
	}#
#
	dev.off()#
	# define final feature#
#
	#(1) allProtein - lambda#
#
	featureSelectionFinal<-featureSelectionOut[featureSelectionOut$Lambda==bestLambda,]#
	featureSelectionFinal<-featureSelectionFinal[,c("PROTEIN","PEPTIDE","FEATURE","weights","PRSSprot","Decision","Lambda")]#
	colnames(featureSelectionFinal)<-c("PROTEIN","PEPTIDE","FEATURE","weights","PRSS","Decision","Lambda")#
#
	write.csv(featureSelectionFinal,file=paste(address,"featureSelectionFinalTable.csv",sep=""))#
	save(featureSelectionFinal,file=paste(address,"featureSelectionFinalTable.RData",sep=""))#
#
	#(2) per-Protein - lambda#
#
	featureSelectionPerProtFinal<-NULL#
	for (i in 1:nlevels(featureSelectionOut$PROTEIN)){#
		temp<-featureSelectionOut[featureSelectionOut$PROTEIN==levels(featureSelectionOut$PROTEIN)[i]&featureSelectionOut$Lambda==perProteinLambda$perProtLambda[i],]	#
		featureSelectionPerProtFinal<-rbind(featureSelectionPerProtFinal,temp)	#
	}#
#
	featureSelectionPerProtFinal<-featureSelectionPerProtFinal[,c("PROTEIN","PEPTIDE","FEATURE","weights","PRSSprot","Decision","Lambda")]#
	colnames(featureSelectionPerProtFinal)<-c("PROTEIN","PEPTIDE","FEATURE","weights","PRSS","Decision","Lambda")#
#
	write.csv(featureSelectionPerProtFinal,file=paste(address,"featureSelectionPerProtFinalTable.csv",sep=""))#
	save(featureSelectionPerProtFinal,file=paste(address,"featureSelectionPerProtFinalTable.RData",sep=""))#
	# perProtLambda#
	workPerProt<-work[work$FEATURE%in%featureSelectionPerProtFinal[featureSelectionPerProtFinal$Decision=="keep","FEATURE"],]#
	workPerProt$PROTEIN<-factor(workPerProt$PROTEIN)#
	workPerProt$PEPTIDE<-factor(workPerProt$PEPTIDE)#
	workPerProt$FEATURE<-factor(workPerProt$FEATURE)#
#
	temp<-featureSelectionPerProtFinal[featureSelectionPerProtFinal$Decision=="keep",c("FEATURE","weights")]#
	workPerProt<-merge(workPerProt,temp,by="FEATURE",sort=FALSE)	#
	at<-which(colnames(workPerProt)=="TRANSITION")#
names<-c(colnames(workPerProt)[2:at],"FEATURE",colnames(workPerProt)[(at+1):dim(workPerProt)[2]])#
	workPerProt<-workPerProt[,names]#
	colnames(workPerProt)[dim(workPerProt)[2]]<-"WEIGHTS"#
	workPerProt<-workPerProt[with(workPerProt,order(PROTEIN,PEPTIDE,FEATURE,LABEL,RUN)),]#
	# allProtLambda#
#
	work<-work[work$FEATURE%in%featureSelectionFinal[featureSelectionFinal$Decision=="keep","FEATURE"],]#
	work$PROTEIN<-factor(work$PROTEIN)#
	work$PEPTIDE<-factor(work$PEPTIDE)#
	work$FEATURE<-factor(work$FEATURE)#
#
	temp<-featureSelectionFinal[featureSelectionFinal$Decision=="keep",c("FEATURE","weights")]#
	work<-merge(work,temp,by="FEATURE",sort=FALSE)	#
	at<-which(colnames(work)=="TRANSITION")#
	names<-c(colnames(work)[2:at],"FEATURE",colnames(work)[(at+1):dim(work)[2]])#
	work<-work[,names]#
	colnames(work)[dim(work)[2]]<-"WEIGHTS"#
	work<-work[with(work,order(PROTEIN,PEPTIDE,FEATURE,LABEL,RUN)),]#
#
	return(work)#
}	#
#
# end-inHouse (The end of the feature selection algorithm)#
###################################
########### make contrast #########
###################################
#
##================================#
## .make.contrast.free: #
## label-free: equal or unequal subjects per group#
## fixed or random subject#
##================================#
#
.make.contrast.free<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(0,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
	feature.c<-rep(0,length(temp))#
	names(feature.c)<-temp#
	if(length(temp)==0) feature.c<-NULL#
#
######
# subject_nested #
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\.")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,1]))	#
		tempdata<-fit$model#
		levels<-unique(tempdata$GROUP)#
		sub.contrast<-contrast.matrix[as.numeric(as.character(levels))]#
		# the base is alway be the first SUBJECT_NESTED#
		# (SUBJECT_NESTED1.1)#
		temp3<-temp2#
			if(length(temp2)==length(sub.contrast)){#
				temp3[1]<-temp2[1]+1 ## this line first because if next is first,length of temp3 becomes >1#
			}else{#
				temp3<-c(1,temp3)#
			}#
		# subjectNested.c<-rep(contrast.matrix/(temp3),temp2) ## in case of unequal sample per group, wrong#
		subjectNested.c<-rep(sub.contrast/(temp3),temp3)[-1]#
		names(subjectNested.c)<-temp#
	}#
	if(length(temp)==0) subjectNested.c<-NULL#
#
######
# subject : for time-course#
######
#	temp<-coef.name[grep("SUBJECT",coef.name)[!grep("SUBJECT",coef.name)%in%c(grep(":",coef.name),grep("NESTED",coef.name))]]#
#	if(length(temp)>0){#
#		subject.c<-rep(0,length(temp))#
#		names(subject.c)<-temp#
#	}#
#	if(length(temp)==0) subject.c<-NULL#
#
	temp<-coef.name[grep("SUBJECT",coef.name)[!grep("SUBJECT",coef.name)%in%c(grep(":",coef.name),grep("NESTED",coef.name))]]#
	if(length(temp)>0){#
#		subject.c<-rep(0,length(temp))#
#		names(subject.c)<-temp#
	tempdata<-fit$model#
	levels<-unique(tempdata$GROUP)#
	labels<-paste("GROUP", levels, sep="")#
	patients<-NULL#
	for(i in 1:length(levels)){#
		sub<-tempdata[tempdata$GROUP==levels[i],]#
		sub.patients<-cbind(GROUP=paste("GROUP", levels[i], sep=""), SUBJECT=paste("SUBJECT", as.character(unique(sub$SUBJECT)), sep=""), Value=contrast.matrix[as.numeric(as.character(levels[i]))])#
		patients<-data.frame(rbind(patients,sub.patients))#
	}#
	patient.count<-tapply(patients$SUBJECT, patients$GROUP, function(x) length(unique(x)))#
	patient.seq<-rep(0, length(temp))#
	for(i in 1:length(as.character(patients$SUBJECT))){#
		match<-any(temp==as.character(patients$SUBJECT)[i])#
		if(match & as.numeric(as.character(patients$Value[i]))!=0){#
			res<-temp == as.character(patients$SUBJECT)[i]#
			index<-which(res==TRUE)#
			group<-as.character(patients[i,]$GROUP)#
			count<-as.numeric(patient.count[names(patient.count)==group])#
			value<-as.numeric(as.character(patients[i,]$Value))#
			patient.value<-c(rep(0,index-1), value/count, rep(0, length(temp)-index))#
		}else{#
			patient.value<-rep(0,length(temp))#
		}#
		patient.seq<-patient.value+patient.seq#
	}#
	subject.c<-patient.seq#
	names(subject.c)<-temp#
	}#
	if(length(temp)==0) subject.c<-NULL#
######
# subject by group : only for time-course - SUBJECT and GROUP (order) even GROUP:SUBJECT in model#
######
#	temp<-coef.name[intersect(grep("SUBJECT",coef.name),grep("GROUP",coef.name))]#
#
#	tempSub<-unique(sub1[,c("GROUP","SUBJECT")])#
#	tempSub1<-xtabs(~GROUP,data=tempSub)#
#	tempSub2<-tempSub1[-1]#
#	if(length(temp)>0){#
#		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
#		temp2<-as.vector(xtabs(~temp1[,2]))	## count per GROUP#
#		#gs.c<-rep(as.vector(contrast.matrix[-1]/(tempSub2)),temp2[1]) ## assume no missing for group and subject#
#		# when Group completely  missing#
#		sub.matrix<-contrast.matrix[unique(tempSub$GROUP)]#
#		gs.c<-rep(as.vector(sub.matrix[-1]/(tempSub2)),each=temp2[1])#
#		names(gs.c)<-temp#
#	}#
#	if(length(temp)==0) gs.c<-NULL#
#
######
# subject by group : only for time-course - SUBJECT and GROUP (order) even GROUP:SUBJECT in model#
######
	temp<-coef.name[intersect(grep("SUBJECT",coef.name),grep("GROUP",coef.name))]#
	if(length(temp)>0){#
#		subject.c<-rep(0,length(temp))#
#		names(subject.c)<-temp#
	tempdata<-fit$model#
	levels<-unique(tempdata$GROUP)#
	labels<-paste("GROUP", levels, sep="")#
	patients<-NULL#
	for(i in 1:length(levels)){#
		sub<-tempdata[tempdata$GROUP==levels[i],]#
		sub.patients<-cbind(GROUP=paste("GROUP", levels[i], sep=""), SUBJECT=paste("SUBJECT", as.character(unique(sub$SUBJECT)), sep=""), Value=contrast.matrix[as.numeric(as.character(levels[i]))])#
		patients<-data.frame(rbind(patients,sub.patients))#
	}#
	patient.count<-tapply(patients$SUBJECT, patients$GROUP, function(x) length(unique(x)))#
	interaction.seq<-rep(0, length(temp))#
	interaction.labels<-paste(as.character(patients$GROUP),as.character(patients$SUBJECT), sep=":")#
	for(i in 1:length(as.character(patients$SUBJECT))){#
		match<-any(temp==interaction.labels[i])#
		if(match & as.numeric(as.character(patients$Value[i]))!=0){#
			res<-temp == interaction.labels[i]#
			index<-which(res==TRUE)#
			group<-as.character(patients[i,]$GROUP)#
			count<-as.numeric(patient.count[names(patient.count)==group])#
			value<-as.numeric(as.character(patients[i,]$Value))#
			interaction.value<-c(rep(0,index-1), value/count, rep(0, length(temp)-index))#
		}else{#
			interaction.value<-rep(0,length(temp))#
		}#
		interaction.seq<-interaction.value+interaction.seq#
	}#
	gs.c<-interaction.seq#
	names(gs.c)<-temp#
	}#
	if(length(temp)==0) gs.c<-NULL#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
### when there are some groups which are all missing#
	tempSub<-as.numeric(as.character(unique(sub1[,c("GROUP")])))#
	tempcontrast<-contrast.matrix[tempSub]#
#
	group.c<-tempcontrast[-1] ## for label-free, need to remove first#
	names(group.c)<-temp#
	if(length(temp)==0) group.c<-NULL#
#
#####
# feature by group : different from labeled#
######
#
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
#
	tempSub<-unique(sub1[,c("GROUP","FEATURE")])#
	tempSub1<-xtabs(~GROUP,data=tempSub)#
	tempSub2<-tempSub1[-1]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
		gf.c<-rep(contrast.matrix[-1]/(tempSub2),temp2)#
		names(gf.c)<-temp#
	}#
#
	if(length(temp)==0) gf.c<-NULL#
#
	## be careful for order#
	contrast<-c(intercept.c,feature.c,subjectNested.c,subject.c,group.c,gs.c,gf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
##================================#
## .make.contrast.based: #
## label-based: equal or unequal subjects per group#
## fixed or random subject#
##================================#
#
.make.contrast.based<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(0,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
	feature.c<-rep(0,length(temp))#
	names(feature.c)<-temp#
	if(length(temp)==0) feature.c<-NULL#
#
######
# subject_nested#
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\.")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,1]))	#
#
		# the base is alway be the first SUBJECT_NESTED#
		# (SUBJECT_NESTED0.0)#
		temp3<-temp2#
		# free:#
		#temp3<-temp2#
		#temp3[1]<-temp2[1]+1#
#
		subjectNested.c<-rep(contrast.matrix/(temp3),temp2)#
		names(subjectNested.c)<-temp#
	}#
	if(length(temp)==0) subjectNested.c<-NULL#
#
######
# subject#
######
	temp<-coef.name[grep("SUBJECT",coef.name)[!grep("SUBJECT",coef.name)%in%c(grep(":",coef.name),grep("NESTED",coef.name))]]#
	if(length(temp)>0){#
		subject.c<-rep(0,length(temp))#
		names(subject.c)<-temp#
	}#
	if(length(temp)==0) subject.c<-NULL#
#
######
# subject by group#
######
	temp<-coef.name[intersect(grep("SUBJECT",coef.name),grep("GROUP",coef.name))]#
	tempSub<-unique(sub1[,c("GROUP","SUBJECT")])#
	tempSub1<-xtabs(~GROUP,data=tempSub)#
	tempSub2<-tempSub1[-1]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
		gs.c<-rep(as.numeric(contrast.matrix)/(tempSub2),temp2)#
		names(gs.c)<-temp#
	}#
	if(length(temp)==0) gs.c<-NULL#
#
######
# subject_original_nested#
######
	temp<-coef.name[grep("SUBJECT_ORIGINAL_NESTED",coef.name)]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\.")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,1]))	#
#
		# the base is alway be the first SUBJECT_ORIGINAL_NESTED#
		# (SUBJECT_ORIGINAL_NESTED1.1)#
		temp3<-temp2#
		temp3[1]<-temp2[1]+1#
#
		subjectOriginalNested.c<-rep(contrast.matrix/(temp3),temp2)#
		names(subjectOriginalNested.c)<-temp#
	}#
	if(length(temp)==0) subjectOriginalNested.c<-NULL#
#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
	### when there are some groups which are all missing#
	tempSub<-as.numeric(as.character(unique(sub1[,c("GROUP")])))#
	group.c<-contrast.matrix[tempSub]#
#
	# free#
	#group.c<-contrast.matrix[-1]#
	names(group.c)<-temp#
	if(length(temp)==0) group.c<-NULL#
#
######
# run#
######
	temp<-coef.name[grep("RUN",coef.name)[!grep("RUN",coef.name)%in%grep(":",coef.name)]]#
	run.c<-rep(0,length(temp))#
	names(run.c)<-temp#
	if(length(temp)==0) run.c<-NULL#
#
#####
# feature by group : different from labeled#
######
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
#
	tempSub<-unique(sub1[,c("GROUP","FEATURE")])#
	tempSub1<-xtabs(~GROUP,data=tempSub)#
	tempSub2<-tempSub1[-1]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
		gf.c<-rep(as.numeric(contrast.matrix)/(tempSub2),temp2)#
		# free#
		#gf.c<-rep(contrast.matrix[-1]/(tempSub2),temp2)#
		names(gf.c)<-temp#
	}#
	if(length(temp)==0) gf.c<-NULL#
#
#####
# run by feature#
######
	temp<-coef.name[intersect(grep("RUN",coef.name),grep("FEATURE",coef.name))]#
	if(length(temp)>0){#
		rf.c<-rep(0,length(temp))#
		names(rf.c)<-temp#
	}#
	if(length(temp)==0) rf.c<-NULL#
#
	contrast<-c(intercept.c,feature.c,subjectNested.c,subject.c,subjectOriginalNested.c,group.c,run.c,gs.c,gf.c,rf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
##================================#
## .make.contrast.group.quantification: #
## label-based/label-free; single/multiple features#
## all fixed subject and run#
##================================#
#
.make.contrast.group.quantification<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(1,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
#	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			feature.c<-rep(1/nlevels(fit$model$FEATURE),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			tempfeature<-eval(getCall(fit)$data)#
#			tempfeature$FEATURE<-factor(tempfeature$FEATURE)#
#			feature.c<-rep(1/nlevels(tempfeature$FEATURE),length(temp))#
#		}#
#		names(feature.c)<-temp#
#	}else{#
#		feature.c<-NULL#
#	}#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("FEATURE","GROUP")])#
		tempSub1<-xtabs(~GROUP+FEATURE,data=tempSub)#
#
		if (nlevels(sub1$LABEL)==2){#
			tempSub1<-tempSub1[-1,]#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
#
		feature.c<-as.numeric(tempSub2[-1])/sum(tempSub2)#
		names(feature.c)<-temp#
	}else{#
		feature.c<-NULL#
	}#
######
# subject_nested#
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\.")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,1]))	#
#
		# the base is alway be the first SUBJECT_NESTED#
		# (SUBJECT_NESTED0.0)#
		if (nlevels(sub1$LABEL)==2){#
			temp3<-temp2#
			subjectNested.c<-rep(contrast.matrix/(temp3),temp2)#
		}#
		# free:#
		if (nlevels(sub1$LABEL)==1){#
			temp3<-temp2#
			if(length(temp2)==length(contrast.matrix)){#
				temp3[1]<-temp2[1]+1 ## this line first because if next is first,length of temp3 becomes >1#
			}else{#
				temp3<-c(1,temp3)#
			}#
			subjectNested.c<-rep(contrast.matrix/(temp3),temp3)[-1]#
		}#
#
		names(subjectNested.c)<-temp#
	}else{#
		subjectNested.c<-NULL#
	}#
#
######
# subject_original#
######
	temp<-coef.name[grep("SUBJECT_ORIGINAL",coef.name)[!grep("SUBJECT_ORIGINAL",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			subjectOrig.c<-rep(1/nlevels(fit$model$SUBJECT_ORIGINAL),length(temp))#
##
#		}else{#
#			### need to fix fit$omdel#
#			subjectOrig.c<-rep(1/nlevels(eval(getCall(fit)$data)$SUBJECT_ORIGINAL),length(temp))#
#		}#
		subjectOrig.c<-rep(1/nlevels(sub1$SUBJECT_ORIGINAL),length(temp))#
		names(subjectOrig.c)<-temp#
	}else{#
		subjectOrig.c<-NULL#
	}#
#
######
# subject_original : group#
######
	temp<-coef.name[intersect(grep("SUBJECT_ORIGINAL",coef.name),grep("GROUP",coef.name))]#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("SUBJECT_ORIGINAL","GROUP")])#
		tempSub1<-xtabs(~GROUP,data=tempSub)#
		tempSub2<-tempSub1[-1]#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
#
		if (nlevels(sub1$LABEL)==2){#
			subjectOrigGroup.c<-rep(as.numeric(contrast.matrix)/(tempSub2),temp2)#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			subjectOrigGroup.c<-rep(contrast.matrix[-1]/(tempSub2),temp2)#
		}#
		names(subjectOrigGroup.c)<-temp#
	}else{#
		subjectOrigGroup.c<-NULL#
	}#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
		if (nlevels(sub1$LABEL)==2){#
			group.c<-contrast.matrix#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			group.c<-contrast.matrix[-1]#
		}#
		names(group.c)<-temp#
		## if some group's coef is NA, need to remove#
		#tempname<-rownames(summary(fit)$coefficients)#
		#tempname1<-tempname[grep("GROUP",tempname)[!grep("GROUP",tempname)%in%grep(":",tempname)]]#
		#group.c<-group.c[names(group.c)==tempname1]#
	}else{#
		group.c<-NULL#
	}#
######
# run#
######
	temp<-coef.name[grep("RUN",coef.name)[!grep("RUN",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			run.c<-rep(1/nlevels(fit$model$RUN),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			run.c<-rep(1/nlevels(eval(getCall(fit)$data)$RUN),length(temp))#
#		}#
			run.c<-rep(1/nlevels(sub1$RUN),length(temp))#
#
		names(run.c)<-temp#
	}else{#
		run.c<-NULL#
	}#
#####
# feature by group : different from labeled#
######
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("GROUP","FEATURE")])#
		tempSub1<-xtabs(~GROUP,data=tempSub)#
		tempSub2<-tempSub1[-1]#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
#
		if (nlevels(sub1$LABEL)==2){#
			gf.c<-rep(as.numeric(contrast.matrix)/(tempSub2),temp2)#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			gf.c<-rep(contrast.matrix[-1]/(tempSub2),temp2)#
		}#
		names(gf.c)<-temp#
	}else{#
		gf.c<-NULL#
	}#
#####
# run by feature#
######
	temp<-coef.name[intersect(grep("RUN",coef.name),grep("FEATURE",coef.name))]#
	tempSub<-dim(unique(sub1[,c("RUN","FEATURE")]))[1]#
	if(length(temp)>0){#
		rf.c<-rep(1/tempSub,length(temp))#
		names(rf.c)<-temp#
	}else{#
		rf.c<-NULL#
	}#
#
	contrast<-c(intercept.c,feature.c,subjectNested.c,subjectOrig.c, subjectOrigGroup.c, group.c,run.c,gf.c,rf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
#
##================================#
## .make.contrast.group.quantification.reference: #
## label-based/label-free; single/multiple features#
## all fixed subject and run#
##================================#
#
.make.contrast.group.quantification.reference<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(1,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
#	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			feature.c<-rep(1/nlevels(fit$model$FEATURE),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			tempfeature<-eval(getCall(fit)$data)#
#			tempfeature$FEATURE<-factor(tempfeature$FEATURE)#
#			feature.c<-rep(1/nlevels(tempfeature$FEATURE),length(temp))#
#		}#
#		names(feature.c)<-temp#
#	}else{#
#		feature.c<-NULL#
#	}#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("FEATURE","GROUP")])#
		tempSub1<-xtabs(~GROUP+FEATURE,data=tempSub)#
		if (nlevels(sub1$LABEL)==2){#
			tempSub1<-tempSub1[-1,]#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
#
		feature.c<-as.numeric(tempSub2[-1])/sum(tempSub2)#
		names(feature.c)<-temp#
	}else{#
		feature.c<-NULL#
	}#
######
# subject_nested#
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		subjectNested.c<-rep(0,length(temp))	#
		names(subjectNested.c)<-temp#
	}else{#
		subjectNested.c<-NULL#
	}#
######
# subject_original#
######
	temp<-coef.name[grep("SUBJECT_ORIGINAL",coef.name)[!grep("SUBJECT_ORIGINAL",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
		subjectOrig.c<-rep(0,length(temp))	#
		names(subjectOrig.c)<-temp#
	}else{#
		subjectOrig.c<-NULL#
	}#
######
# subject_original : group#
######
	temp<-coef.name[intersect(grep("SUBJECT_ORIGINAL",coef.name),grep("GROUP",coef.name))]#
#
	if(length(temp)>0){#
		subjectOrigGroup.c<-rep(0,length(temp))	#
		names(subjectOrigGroup.c)<-temp#
	}else{#
		subjectOrigGroup.c<-NULL#
	}#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
		group.c<-rep(0,length(temp))	#
		names(group.c)<-temp#
	}else{#
		group.c<-NULL#
	}#
#
######
# run#
######
	temp<-coef.name[grep("RUN",coef.name)[!grep("RUN",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			run.c<-rep(1/nlevels(fit$model$RUN),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			temprun<-eval(getCall(fit)$data)#
#			tempfeature$FEATURE<-factor(tempfeature$FEATURE)#
#			feature.c<-rep(1/nlevels(tempfeature$FEATURE),length(temp))#
#			run.c<-rep(1/nlevels(eval(getCall(fit)$d)$RUN),length(temp))#
#		}#
		run.c<-rep(1/nlevels(sub1$RUN),length(temp))#
		names(run.c)<-temp#
	}else{#
		run.c<-NULL#
	}#
#####
# feature by group : different from labeled#
######
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
	if(length(temp)>0){#
		gf.c<-rep(0,length(temp))	#
		names(gf.c)<-temp#
	}else{#
		gf.c<-NULL#
	}#
#
#####
# run by feature#
######
	temp<-coef.name[intersect(grep("RUN",coef.name),grep("FEATURE",coef.name))]#
	tempSub<-dim(unique(sub1[,c("RUN","FEATURE")]))[1]#
	if(length(temp)>0){#
		rf.c<-rep(1/tempSub,length(temp))#
		names(rf.c)<-temp#
	}else{#
		rf.c<-NULL#
	}#
#
	contrast<-c(intercept.c,feature.c,subjectNested.c,subjectOrig.c,subjectOrigGroup.c,group.c,run.c,gf.c,rf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
##================================#
## .make.contrast.subject.quantification.single: #
## label-based/label-free; single features#
## all fixed subject and run#
##================================#
#
.make.contrast.subject.quantification.single<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
#contrastList<-unique(sub1[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
#contrastGroup<-rep(0,nlevels(sub1$GROUP_ORIGINAL))#
#contrastGroup[as.numeric(contrastList[contrast.matrix==1,"GROUP_ORIGINAL"])]<-1#
#
## for label-based	#
	if (nlevels(sub1$LABEL)==2){#
		contrastList<-unique(sub1[,c("GROUP","SUBJECT_ORIGINAL")])[-1,]## remove GROUP==0#
		contrastList$GROUP<-factor(contrastList$GROUP) ## remove '0' group#
#
		contrastGroup<-rep(0,(nlevels(sub1$GROUP)-1))#
		contrastGroup[as.numeric(contrastList[contrast.matrix==1,"GROUP"])]<-1#
	}else{ #
	## for label-free#
		contrastList<-unique(sub1[,c("GROUP","SUBJECT_ORIGINAL")])#
#
		contrastGroup<-rep(0,nlevels(sub1$GROUP))#
		contrastGroup[as.numeric(contrastList[contrast.matrix==1,"GROUP"])]<-1#
	}#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(1,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
#	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			feature.c<-rep(1/nlevels(fit$model$FEATURE),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			tempfeature<-eval(getCall(fit)$data)#
#			tempfeature$FEATURE<-factor(tempfeature$FEATURE)#
#			feature.c<-rep(1/nlevels(tempfeature$FEATURE),length(temp))#
#		}#
#		names(feature.c)<-temp#
#	}else{#
#		feature.c<-NULL#
#	}#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("FEATURE","SUBJECT_NESTED")])#
		tempSub1<-xtabs(~SUBJECT_NESTED+FEATURE,data=tempSub)#
#
		if (nlevels(sub1$LABEL)==2){#
			tempSub1<-tempSub1[-1,]#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
#
		feature.c<-as.numeric(tempSub2[-1])/sum(tempSub2)#
		names(feature.c)<-temp#
	}else{#
		feature.c<-NULL#
	}#
######
# subject_nested#
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		if (nlevels(sub1$LABEL)==2){#
			subjectNested.c<-contrast.matrix#
		}#
#
		# free:#
		if (nlevels(sub1$LABEL)==1){#
			subjectNested.c<-contrast.matrix[-1]#
		}#
		names(subjectNested.c)<-temp#
	}else{#
		subjectNested.c<-NULL#
	}#
#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
		if (nlevels(sub1$LABEL)==2){#
			group.c<-contrastGroup#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			group.c<-contrastGroup[-1]#
		}#
		names(group.c)<-temp#
	}else{#
		group.c<-NULL#
	}#
#
######
# run#
######
	temp<-coef.name[grep("RUN",coef.name)[!grep("RUN",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
#run.c<-rep(1/nlevels(fit$model$RUN),length(temp))#
## when no technical replicate : subject_nested = run#
		run.c<-contrast.matrix[-1]#
#
## however, with technical replicate : subject_nested != run, need others#
#
		names(run.c)<-temp#
	}else{#
		run.c<-NULL#
	}#
#
#####
# feature by group : different from labeled#
######
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("GROUP","FEATURE")])#
		tempSub1<-xtabs(~GROUP,data=tempSub)#
		tempSub2<-tempSub1[-1]#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
#
		if (nlevels(sub1$LABEL)==2){#
			gf.c<-rep(as.numeric(contrastGroup)/(tempSub2),temp2)#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			gf.c<-rep(contrastGroup[-1]/(tempSub2),temp2)#
		}#
		names(gf.c)<-temp#
	}else{#
		gf.c<-NULL#
	}#
#
#####
# run by feature#
######
	temp<-coef.name[intersect(grep("RUN",coef.name),grep("FEATURE",coef.name))]#
	tempSub<-dim(unique(sub1[,c("RUN","FEATURE")]))[1]#
	if(length(temp)>0){#
		rf.c<-rep(1/tempSub,length(temp))#
		names(rf.c)<-temp#
	}else{#
		rf.c<-NULL#
	}#
	contrast<-c(intercept.c,feature.c,subjectNested.c,group.c,run.c,gf.c,rf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
##================================#
## .make.contrast.subject.quantification: #
## label-based/label-free; multiple features#
## all fixed subject and run#
##================================#
#
.make.contrast.subject.quantification<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
## when there are missing value in endogenous, there are error, because the number of group_original and fitted group are different#
#contrastList<-unique(sub1[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
#contrastGroup<-rep(0,nlevels(sub1$GROUP_ORIGINAL))#
		#contrastGroup[as.numeric(contrastList[contrast.matrix==1,"GROUP_ORIGINAL"])]<-1#
#
## for label-based	#
	if (nlevels(sub1$LABEL)==2){#
		contrastList<-unique(sub1[,c("GROUP","SUBJECT_ORIGINAL","SUBJECT_NESTED")])#
		contrastList<-contrastList[contrastList$GROUP!="0",] ## remove GROUP==0#
		contrastList$GROUP<-factor(contrastList$GROUP) ## remove '0' group#
		contrastList$SUBJECT_ORIGINAL<-factor(contrastList$SUBJECT_ORIGINAL) ## remove '0' group#
#
		contrastGroup<-rep(0,(nlevels(sub1$GROUP)-1))#
		contrastGroup[as.numeric(contrastList[contrast.matrix==1,"GROUP"])]<-1#
		contrastSubjectOriginal<-rep(0,(nlevels(sub1$SUBJECT_ORIGINAL)))#
		contrastSubjectOriginal[as.numeric(contrastList[contrast.matrix==1,"SUBJECT_ORIGINAL"])]<-1#
#
	}else{ #
	## for label-free#
		contrastList<-unique(sub1[,c("GROUP","SUBJECT_ORIGINAL")])#
#
		contrastGroup<-rep(0,nlevels(sub1$GROUP))#
		contrastGroup[as.numeric(contrastList[contrast.matrix==1,"GROUP"])]<-1#
	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	if(length(temp)>0){#
		intercept.c<-rep(1,length(temp))#
		names(intercept.c)<-temp#
	}else{#
		intercept.c<-NULL#
	}#
#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
#	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			feature.c<-rep(1/nlevels(fit$model$FEATURE),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			tempfeature<-eval(getCall(fit)$data)#
#			tempfeature$FEATURE<-factor(tempfeature$FEATURE)#
#			feature.c<-rep(1/nlevels(tempfeature$FEATURE),length(temp))#
#		}#
#		names(feature.c)<-temp#
#	}else{#
#		feature.c<-NULL#
#	}#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("FEATURE","SUBJECT_NESTED")])#
		tempSub1<-xtabs(~SUBJECT_NESTED+FEATURE,data=tempSub)#
#
		if (nlevels(sub1$LABEL)==2){#
			tempSub1<-tempSub1[-1,]#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
#
		feature.c<-as.numeric(tempSub2[-1])/sum(tempSub2)#
		names(feature.c)<-temp#
	}else{#
		feature.c<-NULL#
	}#
######
# subject_nested#
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		if (nlevels(sub1$LABEL)==2){#
			subjectNested.c<-contrast.matrix#
		}#
#
		# free:#
		if (nlevels(sub1$LABEL)==1){#
			subjectNested.c<-contrast.matrix[-1]#
		}#
		names(subjectNested.c)<-temp#
	}else{#
		subjectNested.c<-NULL#
	}#
######
# subject_original#
######
	temp<-coef.name[grep("SUBJECT_ORIGINAL",coef.name)[!grep("SUBJECT_ORIGINAL",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
		subjectOrig.c<-contrastSubjectOriginal[-1]#
		names(subjectOrig.c)<-temp#
	}else{#
		subjectOrig.c<-NULL#
	}#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
		if (nlevels(sub1$LABEL)==2){#
			group.c<-contrastGroup#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			group.c<-contrastGroup[-1]#
		}#
		names(group.c)<-temp#
	}else{#
		group.c<-NULL#
	}#
#
######
# run#
######
	temp<-coef.name[grep("RUN",coef.name)[!grep("RUN",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			run.c<-rep(1/nlevels(fit$model$RUN),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			run.c<-rep(1/nlevels(eval(getCall(fit)$data)$RUN),length(temp))#
#		}#
		run.c<-rep(1/nlevels(sub1$RUN),length(temp))#
		names(run.c)<-temp#
	}else{#
		run.c<-NULL#
	}#
#
#####
# feature by group : different from labeled#
######
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("GROUP","FEATURE")])#
		tempSub1<-xtabs(~GROUP,data=tempSub)#
		tempSub2<-tempSub1[-1]#
		temp1<-t(matrix(unlist(strsplit(as.character(temp),"\\:")),nrow=2))#
		temp2<-as.vector(xtabs(~temp1[,2]))	#
#
		if (nlevels(sub1$LABEL)==2){#
			gf.c<-rep(as.numeric(contrastGroup)/(tempSub2),temp2)#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			gf.c<-rep(contrastGroup[-1]/(tempSub2),temp2)#
		}#
		names(gf.c)<-temp#
	}else{#
		gf.c<-NULL#
	}#
#####
# run by feature#
######
	temp<-coef.name[intersect(grep("RUN",coef.name),grep("FEATURE",coef.name))]#
	tempSub<-dim(unique(sub1[,c("RUN","FEATURE")]))[1]#
	if(length(temp)>0){#
		rf.c<-rep(1/tempSub,length(temp))#
		names(rf.c)<-temp#
	}else{#
		rf.c<-NULL#
	}#
#
	contrast<-c(intercept.c,feature.c,subjectNested.c,subjectOrig.c,group.c,run.c,gf.c,rf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
##================================#
## .make.contrast.subject.quantification.reference: #
## label-based/label-free; single/multiple features#
## all fixed subject and run#
##================================#
#
.make.contrast.subject.quantification.reference<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(1,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
#
######
# feature#
######
	temp<-coef.name[grep("FEATURE",coef.name)[!grep("FEATURE",coef.name)%in%grep(":",coef.name)]]#
#	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			feature.c<-rep(1/nlevels(fit$model$FEATURE),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			tempfeature<-eval(getCall(fit)$data)#
#			tempfeature$FEATURE<-factor(tempfeature$FEATURE)#
#			feature.c<-rep(1/nlevels(tempfeature$FEATURE),length(temp))#
#		}#
#		names(feature.c)<-temp#
#	}else{#
#		feature.c<-NULL#
#	}#
#
	if(length(temp)>0){#
		tempSub<-unique(sub1[,c("FEATURE","SUBJECT_NESTED")])#
		tempSub1<-xtabs(~SUBJECT_NESTED+FEATURE,data=tempSub)#
		if (nlevels(sub1$LABEL)==2){#
			tempSub1<-tempSub1[-1,]#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
		# free#
		if (nlevels(sub1$LABEL)==1){#
			tempSub2<-tempSub1[contrast.matrix==1,]#
		}#
#
		feature.c<-as.numeric(tempSub2[-1])/sum(tempSub2)#
		names(feature.c)<-temp#
	}else{#
		feature.c<-NULL#
	}#
######
# subject_nested#
######
	temp<-coef.name[grep("SUBJECT_NESTED",coef.name)]#
	if(length(temp)>0){#
		subjectNested.c<-rep(0,length(temp))	#
		names(subjectNested.c)<-temp#
	}else{#
		subjectNested.c<-NULL#
	}#
#
######
# subject_original#
######
	temp<-coef.name[grep("SUBJECT_ORIGINAL",coef.name)[!grep("SUBJECT_ORIGINAL",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
		subjectOrig.c<-rep(0,length(temp))#
		names(subjectOrig.c)<-temp#
	}else{#
		subjectOrig.c<-NULL#
	}#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
	if(length(temp)>0){#
		group.c<-rep(0,length(temp))	#
		names(group.c)<-temp#
	}else{#
		group.c<-NULL#
	}#
#
######
# run#
######
	temp<-coef.name[grep("RUN",coef.name)[!grep("RUN",coef.name)%in%grep(":",coef.name)]]#
	if(length(temp)>0){#
#		if(class(fit)=="lm"){#
#			run.c<-rep(1/nlevels(fit$model$RUN),length(temp))#
#		}else{#
#			### need to fix fit$omdel#
#			run.c<-rep(1/nlevels(eval(getCall(fit)$data)$RUN),length(temp))#
#		}#
		run.c<-rep(1/nlevels(sub1$RUN),length(temp))#
		names(run.c)<-temp#
	}else{#
		run.c<-NULL#
	}#
#####
# feature by group : different from labeled#
######
	temp<-coef.name[intersect(grep("GROUP",coef.name),grep("FEATURE",coef.name))]#
	if(length(temp)>0){#
		gf.c<-rep(0,length(temp))	#
		names(gf.c)<-temp#
	}else{#
		gf.c<-NULL#
	}#
#
#####
# run by feature#
######
	temp<-coef.name[intersect(grep("RUN",coef.name),grep("FEATURE",coef.name))]#
	tempSub<-dim(unique(sub1[,c("RUN","FEATURE")]))[1]#
	if(length(temp)>0){#
		rf.c<-rep(1/tempSub,length(temp))#
		names(rf.c)<-temp#
	}else{#
		rf.c<-NULL#
	}#
	contrast<-c(intercept.c,feature.c,subjectNested.c,subjectOrig.c,group.c,run.c,gf.c,rf.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
#
##================================#
## label-free, single#
##================================#
.make.contrast.free.single<-function(fit,contrast.matrix,sub1){#
#
	if(class(fit)=="lm"){#
		coef.name<-names(coef(fit))#
	}else{#
		coef.name<-names(fixef(fit))#
	}#
#
## change contrast.matrix without Group1#
#	cons=1#
#	if(contrast.matrix[1]==0) contrast.free<-contrast.matrix[-1]#
#	if(contrast.matrix[1]<0){ #
#		contrast.free<-contrast.matrix[-1]/abs(contrast.matrix[1])#
#		cons=abs(contrast.matrix[1])#
#		}#
#	if(contrast.matrix[1]>0){ #
#		contrast.free<-contrast.matrix[-1]*(-1)/contrast.matrix[1]#
#		cons=contrast.matrix[1]*(-1)#
#		}#
#
#	if(class(fit)=="lm"){#
#		coef.name<-names(coef(fit))#
#	}else{#
#		coef.name<-names(fixef(fit))#
#	}#
#
######
# intercept#
######
	temp<-coef.name[grep("Intercept",coef.name)]#
	intercept.c<-rep(0,length(temp))#
	names(intercept.c)<-temp#
	if(length(temp)==0) intercept.c<-NULL#
######
# subject#
######
	temp<-coef.name[grep("SUBJECT",coef.name)[!grep("SUBJECT",coef.name)%in%c(grep(":",coef.name),grep("NESTED",coef.name))]]#
	if(length(temp)>0){#
#		subject.c<-rep(0,length(temp))#
#		names(subject.c)<-temp#
	tempdata<-fit$model#
	levels<-unique(tempdata$GROUP)#
	labels<-paste("GROUP", levels, sep="")#
	patients<-NULL#
	for(i in 1:length(levels)){#
		sub<-tempdata[tempdata$GROUP==levels[i],]#
		sub.patients<-cbind(GROUP=paste("GROUP", levels[i], sep=""), SUBJECT=paste("SUBJECT", as.character(unique(sub$SUBJECT)), sep=""), Value=contrast.matrix[as.numeric(as.character(levels[i]))])#
		patients<-data.frame(rbind(patients,sub.patients))#
	}#
	patient.count<-tapply(patients$SUBJECT, patients$GROUP, function(x) length(unique(x)))#
	patient.seq<-rep(0, length(temp))#
	for(i in 1:length(as.character(patients$SUBJECT))){#
		match<-any(temp==as.character(patients$SUBJECT)[i])#
		if(match & as.numeric(as.character(patients$Value[i]))!=0){#
			res<-temp == as.character(patients$SUBJECT)[i]#
			index<-which(res==TRUE)#
			group<-as.character(patients[i,]$GROUP)#
			count<-as.numeric(patient.count[names(patient.count)==group])#
			value<-as.numeric(as.character(patients[i,]$Value))#
			patient.value<-c(rep(0,index-1), value/count, rep(0, length(temp)-index))#
		}else{#
			patient.value<-rep(0,length(temp))#
		}#
		patient.seq<-patient.value+patient.seq#
	}#
	subject.c<-patient.seq#
	names(subject.c)<-temp#
	}#
	if(length(temp)==0) subject.c<-NULL#
######
# group : different from labeled#
######
	temp<-coef.name[grep("GROUP",coef.name)[!grep("GROUP",coef.name)%in%grep(":",coef.name)]]#
#
### when there are some groups which are all missing#
	tempSub<-as.numeric(as.character(unique(sub1[,c("GROUP")])))#
	tempcontrast<-contrast.matrix[tempSub]#
#
	group.c<-tempcontrast[-1] ## for label-free, need to remove first#
	names(group.c)<-temp#
	if(length(temp)==0) group.c<-NULL#
######
# subject by group : only for time-course - SUBJECT and GROUP (order) even GROUP:SUBJECT in model#
######
	temp<-coef.name[intersect(grep("SUBJECT",coef.name),grep("GROUP",coef.name))]#
	if(length(temp)>0){#
#		subject.c<-rep(0,length(temp))#
#		names(subject.c)<-temp#
	tempdata<-fit$model#
	levels<-unique(tempdata$GROUP)#
	labels<-paste("GROUP", levels, sep="")#
	patients<-NULL#
	for(i in 1:length(levels)){#
		sub<-tempdata[tempdata$GROUP==levels[i],]#
		sub.patients<-cbind(GROUP=paste("GROUP", levels[i], sep=""), SUBJECT=paste("SUBJECT", as.character(unique(sub$SUBJECT)), sep=""), Value=contrast.matrix[as.numeric(as.character(levels[i]))])#
		patients<-data.frame(rbind(patients,sub.patients))#
	}#
	patient.count<-tapply(patients$SUBJECT, patients$GROUP, function(x) length(unique(x)))#
	interaction.seq<-rep(0, length(temp))#
	interaction.labels<-paste(as.character(patients$GROUP),as.character(patients$SUBJECT), sep=":")#
	for(i in 1:length(as.character(patients$SUBJECT))){#
		match<-any(temp==interaction.labels[i])#
		if(match & as.numeric(as.character(patients$Value[i]))!=0){#
			res<-temp == interaction.labels[i]#
			index<-which(res==TRUE)#
			group<-as.character(patients[i,]$GROUP)#
			count<-as.numeric(patient.count[names(patient.count)==group])#
			value<-as.numeric(as.character(patients[i,]$Value))#
			interaction.value<-c(rep(0,index-1), value/count, rep(0, length(temp)-index))#
		}else{#
			interaction.value<-rep(0,length(temp))#
		}#
		interaction.seq<-interaction.value+interaction.seq#
	}#
	gs.c<-interaction.seq#
	names(gs.c)<-temp#
	}#
	if(length(temp)==0) gs.c<-NULL#
### combine all#
	contrast<-c(intercept.c,group.c, subject.c, gs.c)#
#
	if(class(fit)=="lm"){#
		contrast1<-contrast[!is.na(coef(fit))]#
	}else{#
		contrast1<-contrast[!is.na(fixef(fit))]#
	}#
	return(contrast1)#
}#
###################################
###################################
########### estimate   ############
###################################
##################################	#
.getParameterFixed<-function(obj){#
	temp1<-summary.lm(obj)#
	cf <- temp1$coefficients#
	vcv <- temp1$cov.unscaled * temp1$sigma^2	#
	df <- obj$df.residual#
	parameter<-list(cf=cf, vcv=vcv, df=df)#
	return(parameter)#
}#
#
.getParameterRandom<-function(obj,df.full){#
	cf <- as.matrix(fixef(obj))#
	vcv <- as.matrix(vcov(obj))#
	df <- df.full#
	parameter<-list(cf=cf, vcv=vcv, df=df)#
	return(parameter)#
}#
#
.estimableFixedRandom<-function(parameter,cm){#
	cm <- matrix(cm, nrow=1)#
	ct <- cm %*% parameter$cf[, 1]#
	vc <- sqrt(diag(cm %*% parameter$vcv %*% t(cm)))#
	prob <- 2 * (1 - pt(abs(ct/vc), parameter$df))#
	result<-cbind(est=ct,stderr=vc,t=ct/vc,df=parameter$df,prob=prob)#
	colnames(result)<-c("logFC","SE","Tvalue","DF","pvalue")#
#
	return(result)#
}#
#
###########################################################################################
#
.estimableFixedQuantification<-function(cf,cm){#
#
	cm <- matrix(cm, nrow=1)#
	ct <- cm %*% cf[, 1]#
	result<-cbind(est=ct)#
	colnames(result)<-c("log-intensities")#
	return(result)#
}#
#
###########################################################################################
#
.estimableRandomQuantification<-function(cf,cm){#
#
	cm <- matrix(cm, nrow=1)#
	ct <- cm %*% cf#
	result<-cbind(est=ct)#
	colnames(result)<-c("log-intensities")#
	return(result)#
}#
###########################################################################################
#
.iter.wls.fit.model<-function(data,fit,nrepeats){#
	for(i in 1:nrepeats){	#
		if(i==1){#
			## lm or lmer#
			if(class(fit)=="lm"){#
				abs.resids<-data.frame(abs.resids=abs(fit$residuals))#
				fitted<-data.frame(fitted=fit$fitted.values)#
			}else{#
				abs.resids<-data.frame(abs.resids=abs(resid(fit)))#
				fitted<-data.frame(fitted=fitted(fit))#
			}#
			data<-data.frame(data,"abs.resids"=abs.resids,"fitted"=fitted)					#
#			data<-merge(data,abs.resids,by="row.names",all=T)#
#			rownames(data)<-data$Row.names#
#			data<-merge(data, fitted, by="row.names",all=T)#
#			rownames(data)<-data$Row.names#
		}#
		fit.loess<-loess(abs.resids~fitted, data=data)#
		loess.fitted<-data.frame(loess.fitted=fitted(fit.loess))#
		data<-data.frame(data,"loess.fitted"=loess.fitted)				#
#
#		rownames(loess.fitted)<-names(resid(fit.loess))#
#		data<-merge(data, loess.fitted, by="row.names",all=T)#
#		rownames(data)<-data$Row.names#
		## loess fitted valuaes are predicted sd#
		data$weight<-1/(data$loess.fitted^2)#
		data<-data[,-which(colnames(data) %in% "abs.resids")]#
		## re-fit using weight#
		if(class(fit)=="lm"){#
			wls.fit<-lm(formula(fit),data=data,weights=weight)#
		}else{#
			wls.fit<-lmer(formula(fit),data=data,weights=weight)#
		}#
#
		## lm or lmer#
#		if(class(fit)=="lm"){#
#			residuals<-data.frame(residuals=wls.fit$residuals)#
#		}else{#
#			residuals<-data.frame(residuals=resid(wls.fit))#
#		}#
#		data<-merge(data,residuals,by="row.names",all=T)#
#		rownames(data)<-data$Row.names#
		## lm or lmer#
		if(class(wls.fit)=="lm"){#
			abs.resids<-data.frame(abs.resids=abs(wls.fit$residuals))#
		}else{#
			abs.resids<-data.frame(abs.resids=abs(resid(wls.fit)))#
		}#
		data<-data.frame(data,"abs.resids"=abs.resids)				#
#
#		data<-merge(data,abs.resids,by="row.names",all=T)#
#		rownames(data)<-data$Row.names#
		data<-data[,-which(colnames(data) %in% c("loess.fitted","weight"))]#
	}#
#
	return(wls.fit)#
}
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
temp
class(temp)
names(temp)
head(temp$result)
fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP , data = data)
fit.full
names(fit.full)
fixedPara<-.getParameterFixed(fit.full)
fixedPara
head(temp$result)
temp
names(temp)
fit.full
.fit.model<-function(contrast.matrix,data,labeled,scopeOfBioReplication,scopeOfTechReplication,interference,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup){#
	nrepeats=3#
	## label-free : use only light intensity, need to change contrast.matrix without Group0	#
	if(!labeled){#
		## use only light#
		data2<-subset(data,LABEL=="L")#
		data2$GROUP<-factor(data2$GROUP)#
		data2$SUBJECT<-factor(data2$SUBJECT)#
#
		# when single subject, there is no need to distinguish case-control and time course; fixed subject or random subject, and no need to have GXF since there is not enough degree of freedom, hence no separatation of interference	#
		if (singleSubject){#
			if(!TechReplicate){#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP , data = data2)#
			}else{#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + GROUP:FEATURE , data = data2)#
			}#
			## make equal variance for feature#
			if(!equalFeatureVar){#
				fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
			}#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", paste(origGroup[GroupComparisonAgreement$positionMiss],collapse=", "), " are missing completely.")#
#
					out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
		} ## singleSubject is TRUE#
#
		if (!singleSubject){#
		# when subject is fixed, it is ok using lm function. When we use lm, model with nested or crossed samples have the same results. In the future, if we want to have sample quantification. We need to separate the cases of nested or crossed samples.#
#
		#===========#
		# (1) Subject:F; case-control/time course#
		# since it's fixed effect model, the results of nested model and crossed model are the same#
		# but when there is unequal subject, the SE is slightly different#
		# also no missing patterns (GXF, G, S) will stop the test#
		#==========	#
			if (scopeOfBioReplication=="restricted"){#
				# case-control#
				if (!repeated){	#
					if(interference){#
     					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data2)#
					}else{#
	  					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP, data = data2)#
					}#
				}else{	## time-course#
					if(interference){#
      					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data2)#
      					#fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + SUBJECT:GROUP + GROUP + FEATURE:GROUP , data = data2)#
					}else{#
	  					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP, data = data2)#
	  					#fit.full<-lm(ABUNDANCE ~ FEATURE + SUBJECT + SUBJECT:GROUP + GROUP, data = data2)#
#
					}#
				}#
	     		## make equal variance for feature#
	     		if(!equalFeatureVar){#
	     			fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
	     		}#
				## get parameter from model before all comparison#
				fixedPara<-.getParameterFixed(fit.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
						out<-.estimableFixedRandom(fixedPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)#
				} # end loop for contrast#
#
			} ## bioRep is restricted#
	#===========#
	# (2) Subject:R; #
	# since it's mixed effect model, the results of nested model and crossed model are not the same#
	# df of nested and crossed are not the same as well.#
	# also missing patterns (GXF) will stop the test, but (G, S) will not#
	#==========	#
			if (scopeOfBioReplication=="expanded"){#
#
				# case-control#
				if (!repeated){#
					if(interference){#
						if(!MissGroupByFeature){#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1-1)#
      					}else{  ## MissGroupByFeature==TRUE#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP, data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1-1)#
      					}#
					}else{ ## interference==FALSE#
	  					fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP, data = data2)#
	  					temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  					temp1<-xtabs(~GROUP,data=temp)#
      					df.full<-sum(temp1-1)#
					}#
				}else{  ##time-course#
					if(interference){#
						if(!MissGroupByFeature){#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + FEATURE:GROUP , data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1[-1]-1)#
      					}else{ ## MissGroupByFeature==TRUE#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +   (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP, data = data2)#
     						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1[-1]-1)#
      					}#
					}else{  ## interference==FALSE#
	  					fit.full<-lmer(ABUNDANCE ~ FEATURE +   (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP, data = data2)#
	  					temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  					temp1<-xtabs(~GROUP,data=temp)#
      					df.full<-sum(temp1[-1]-1)#
					}#
				}#
	     		## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)#
				} # end loop for contrast#
			}## bio rep is expanded#
#
		}## singleSub=FALSE#
#
	} ## label -free	#
	if(labeled){	#
	# when single subject, there is no need to distinguish case-control and time course; fixed subject or random subject, and no need to have GXF RXF since there is not enough degree of freedom, hence no separatation of interference	#
		if (singleSubject){#
			message(paste("*** ",unique(data$PROTEIN)," has single subject per condition. Only restricted scope of conclusion is possible."))#
			if(TechReplicate){#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + RUN + GROUP:FEATURE + RUN:FEATURE, data = data)#
			}else{#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + RUN, data = data)#
			}#
	     	## make equal variance for feature#
	     	if(!equalFeatureVar){#
	   			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
	   		}#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
#
		} ## singleSub is True#
#
		if (!singleSubject){#
		##########################	#
		# (1) Subject: F, Run: F#
		##########################	#
#
			if(scopeOfBioReplication=="restricted" & scopeOfTechReplication=="restricted"){#
				## (1.1) case-control#
				if (!repeated){#
					if(interference){#
						fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
					}else{#
						fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + RUN, data = data)#
					}#
				}else{  ## (1.2) time-course#
					if(interference){#
						fit.full<-lm(ABUNDANCE ~ FEATURE  +  SUBJECT_NESTED + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
					}else{#
						fit.full<-lm(ABUNDANCE ~ FEATURE  +  SUBJECT_NESTED  + GROUP + RUN, data = data)#
					}#
				}	#
		     	## make equal variance for feature#
	     		if(!equalFeatureVar){#
	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
	     		}#
				## get parameter from model#
				fixedPara<-.getParameterFixed(fit.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(fixedPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			} ## fSfR#
		##########################	#
		# (2) Subject: R, Run: F#
		##########################	#
#
			if(scopeOfBioReplication=="expanded"&scopeOfTechReplication=="restricted"){#
				## (2.1) case-control#
				if (!repeated){#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN, data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)		#
						}#
					}else{ ##interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN, data = data)#
						# calculate DF of SUBJECT_NESTED#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-1]-1)#
					}#
				}else{  ## (2.2) time-course#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN, data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)	#
						}#
					}else{  ##interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + RUN, data = data)#
						# calculate DF of SUBJECT:GROUP#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-c(1,2)]-1)#
					}	#
				}#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}	#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			}	#rSfR#
		##########################	#
		# (3) Subject: F, Run: R#
		# only SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP can work for model fitting#
		# therefore, there is no need to separate case-control and time course#
		# however, when there is unequal subject, we need to fit additive model of removing SUBJECT by GROUP#
		##########################	#
#
			if(scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
				## (3.1) equal subject per group#
				if (!UnequalSubject){#
					if(interference){#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)$df.residual#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
						}#
					}else{  ## interference#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN), data = data)#
						df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
					}#
				}else{ ## (3.2) unequal subject per group#
					if(interference){		#
						if(!MissGroupByFeature & !MissRunByFeature){#
#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)$df.residual#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL  + GROUP + (1|RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT  + RUN, data = data)$df.residual#
						}			#
					}else{ ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL  + GROUP + (1|RUN), data = data)#
						df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
					}#
				}	#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			} #fSrR	#
		##########################	#
		# (4) Subject: R, Run: R#
		##########################	#
#
			if(scopeOfBioReplication=="expanded" & scopeOfTechReplication=="expanded"){#
				## (4.1) case-control#
				if (!repeated){#
					if(interference){#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED)  + GROUP + (1|RUN), data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}#
					}else{ ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + (1|RUN), data = data)#
						# calculate DF of SUBJECT_NESTED#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-1]-1)#
					}#
				}else{  ## (4.2) time-course#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN), data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}#
					}else{  ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + (1|RUN), data = data)#
						# calculate DF of SUBJECT:GROUP#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-c(1,2)]-1)#
					}#
				}	#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison	#
			} #rSrR		#
		} ## singleSub is FALSE#
	}## label-based#
	if(class(fit.full)=="lm"){  ### lm model#
		finalresid<-fit.full$residuals#
		finalfitted<-fit.full$fitted.values#
	}else{   ### lmer model#
		finalresid<-resid(fit.full)#
		finalfitted<-fitted(fit.full)#
	}#
	finalout<-list(result=allout,valueresid=finalresid, valuefitted=finalfitted, fittedModel=fit.full)	#
#
	return(finalout)#
}
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
temp
names(fit.full)
names(temp)
temp$fittedModel
groupComparison2<-function(contrast.matrix=contrast.matrix,data=data,labeled=TRUE, scopeOfBioReplication="restricted", scopeOfTechReplication="expanded", interference=TRUE,equalFeatureVar=TRUE,missing.action = "nointeraction"){#
#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile, header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - groupComparison function"," "),ncol=1))#
	## check input is correct#
	## data format#
	rawinput<-c("ProteinName","PeptideSequence","PrecursorCharge","FragmentIon","ProductCharge","IsotopeLabelType","Condition","BioReplicate","Run","Intensity")#
	if(length(setdiff(toupper(rawinput),toupper(colnames(data))))==0){#
		processout<-rbind(processout,c(paste("The required input - data : did not process from dataProcess function. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("Please use 'dataProcess' first. Then use output of dataProcess function as input in groupComparison.")#
	}#
	## contrast. matrix#
	if(ncol(contrast.matrix)!=length(unique(data$GROUP_ORIGINAL))){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: the number of column and the number of group are not the same. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("Please check contrast matrix. The number of group in data set is different with columns of contrast.matrix.")#
	}#
	# check whether row.names of contrast.matrix.sub exists or not#
	if(sum(is.null(row.names(contrast.matrix)))>0){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: need row names of contrast.matrix . - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("No row.names of comparison exist.\n")#
	}#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(sum(unique(data$LABEL) %in% "H")==0 & labeled==TRUE){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. labeled should be 'FALSE'. Therefore now use labeled=FALSE")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 message("Dataset is based on label-free experiment. MSstats will use \"labeled\"=FALSE.")#
		 labeled<-FALSE#
	}#
	## other option value#
	if(!(scopeOfTechReplication=="restricted" | scopeOfTechReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfTechReplication : 'scopeOfTechReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfTechReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	}#
	if(!(scopeOfBioReplication=="restricted" | scopeOfBioReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfBioReplication : 'scopeOfBioReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfBioReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	} #
	if(!(interference==TRUE | interference==FALSE) | !is.logical(interference)){#
		processout<-rbind(processout,c(paste("The required input - interference : 'interference' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'interference' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(!(equalFeatureVar==TRUE | equalFeatureVar==FALSE) | !is.logical(equalFeatureVar)){#
		processout<-rbind(processout,c(paste("The required input - equalFeatureVar : 'equalFeatureVar' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("'equalFeatureVar' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(equalFeatureVar==FALSE & (scopeOfBioReplication=="expanded" | scopeOfTechReplication=="expanded")){#
		message("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication.")#
		processout<-rbind(processout,c("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication."))#
		write.table(processout, file=finalfile, row.names=FALSE)#
	}#
	if(!(missing.action %in% c("nointeraction", "impute", "remove"))){#
		processout<-rbind(processout,c(paste("The required input - missing.action : 'missing.action' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'missing.action' must be one of \"nointeraction\", \"impute\", or \"remove\".")#
	}#
#
	## all input#
		processout<-rbind(processout,c(paste("labeled = ",labeled,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfBioReplication = ",scopeOfBioReplication,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfTechReplication = ", scopeOfTechReplication,sep="")))#
		processout<-rbind(processout,c(paste("interference = ",interference,sep="")))#
		processout<-rbind(processout,c(paste("equalFeatureVar = ",equalFeatureVar,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
## check whether case-control(FALSE) or time-course(TRUE)#
repeated<-.checkRepeated(data)#
#
	if(repeated){ #
		processout<-rbind(processout,c(paste("Time course design of experiment - okay")))#
	}else{#
		processout<-rbind(processout,c(paste("Case control design of experiment - okay")))#
#
	}#
	write.table(processout, file=finalfile, row.names=FALSE)#
## since case-control(FALSE) with fixed subject and random run will fit the crossed model#
# we need to set subject_original to non-unique#
#
if(repeated==FALSE&scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
	test<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	test<- test[with(test, order(GROUP_ORIGINAL,SUBJECT_ORIGINAL)),]#
	test$GROUP_ORIGINAL<-factor(test$GROUP_ORIGINAL)#
	test1<-as.matrix(xtabs(~test[,1]))#
	test$SUBJECT_ORIGINAL_NOUNIQUE<-as.numeric(unlist(apply(test1,1,function(x) seq(x))))#
#
	data$SUBJECT_ORIGINAL<-as.character(data$SUBJECT_ORIGINAL)#
#
	for (i in 1:length(unique(test$SUBJECT_ORIGINAL_NOUNIQUE))){#
		list<-test$SUBJECT_ORIGINAL[test$SUBJECT_ORIGINAL_NOUNIQUE==i]#
		data$SUBJECT_ORIGINAL[data$SUBJECT_ORIGINAL%in%list]<-i	#
	}#
#
	data$SUBJECT_ORIGINAL<-factor(data$SUBJECT_ORIGINAL)#
}#
data$PROTEIN<-factor(data$PROTEIN)	#
#
## for final result report#
out<-NULL#
outsummary<-NULL#
outfitted<-NULL#
dataafterfit<-NULL#
#
##################################
### how to handle missingness for endogenous#
#
data.l<-data[data$LABEL=="L",]#
data.h<-data[data$LABEL=="H",]#
#
missingPeptides<-.checkMissFeature(data.l)#
#
protein.list = tapply ( data.l$FEATURE, data.l$PROTEIN, function ( x ) unique ( as.character ( x ) ) )#
#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
## Impute for missing endogenous intensity#
if ( missing.action == "impute" ) { #
	if(length(missingPeptides) > 0){#
		dataBySample <- tapply(data.l$ABUNDANCE, list(data.l$SUBJECT_ORIGINAL, data.l$FEATURE), function(x) min(x, na.rm = TRUE))#
		dataBySample <- dataBySample[!(apply(dataBySample, 1, function(x) sum(is.na(x))) == ncol(dataBySample)), ]#
#
		if(!is.numeric(dataBySample)){ ## only one subject#
			minValuePerSample <- apply(dataBySample, 1, function(x) min(x, na.rm = TRUE))#
		}else{#
			minValuePerSample<-min(dataBySample, na.rm=TRUE)#
		}#
		imputeValue <- mean(minValuePerSample[!is.infinite(minValuePerSample)], na.rm = TRUE)#
#
		for(i in 1:length(missingPeptides)){#
			sub <- data.l[data.l$FEATURE == missingPeptides[i], ]#
			t <- tapply(sub$ABUNDANCE, sub$GROUP, function(x) sum(x > 0, na.rm = TRUE))#
			missingConds <- names(t)[which(t == 0 | is.na(t))]		#
			data.l[data.l$FEATURE %in% missingPeptides[i] & data.l$GROUP %in% missingConds, ]$ABUNDANCE <- imputeValue#
		}#
#
		if(length(missingPeptides) > 0){#
			number.missing <- length(missingPeptides)#
			message(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = ""))	#
			processout<-rbind(processout,c(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = "")))#
			write.table(processout, file=finalfile, row.names=FALSE)	#
		}#
	}#
#	data<-rbindlist(list(data.l,data.h))#
	data<-rbind(data.l,data.h)#
#
}#
## even though it is not the case, user can do with no interaction ( no else command)#
## #
if ( missing.action == "remove" ){#
	data<-data[-which(data$FEATURE %in% missingPeptides),]#
#
	message("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model.")#
	processout<-rbind(processout,c("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
#
}#
## for assigning interference#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
#
###
	processout<-rbind(processout,c(paste("missing.action : ",missing.action," - okay",sep="")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
###==================================================#
### start to analyze by protein ID#
#
	### need original group information#
	origGroup<-unique(data$GROUP_ORIGINAL)#
for (i in 1:nlevels(data$PROTEIN)){#
#
	sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)#
	## need to assigning whether interaction term is included or not#
	remove.interaction<-interference#
if ( missing.action == "nointeraction" & missing.results [ i ]){#
	remove.interaction = FALSE#
	message("** ",paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = ""))#
	processout<-rbind(processout,c(paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = "")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
}#
#
	message(paste("Testing a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")"))#
	if(singleFeature){#
		message("** Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted.")#
		processout<-rbind(processout,c(paste("Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		temp<-try(.fit.model.single(contrast.matrix,sub,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup),silent=TRUE)#
#
	}	#
	if(!singleFeature){#
#
# not sure it is correct and what it means#
#	noRunFeature<-.checkRunbyFeature(sub)#
#	if(noRunFeature) unbalanced=TRUE#
	temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)#
#
	}#
## fix(apr 16)#
	if(class(temp)=="try-error") {#
		message("*** error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.")#
		processout<-rbind(processout,c(paste("error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		tempresult<-list(result=NULL,valueresid=NULL, valuefitted=NULL, fittedModel=NULL)#
		for(k in 1:nrow(contrast.matrix)){	#
			tempresult$result<-rbind(tempresult$result, data.frame(Protein=levels(data$PROTEIN)[i],Label=row.names(contrast.matrix)[k], logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA))#
		}#
	}else{#
		tempresult<-temp#
	}#
#
## comparison result table#
#	out<-rbindlist(list(out,tempresult$result))#
	out<-rbind(out,tempresult$result)#
#
## for checking model assumptions#
## add residual and fitted after fitting the model#
	if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}#
	## order concerned#
#	residuals<-data.frame(temp$valueresid)#
#	fitted<-data.frame(temp$valuefitted)#
#	sub<-merge(sub,residuals,by="row.names",all=T)#
#	rownames(sub)<-sub$Row.names#
#	sub<-merge(sub, fitted, by="row.names",all=T)#
#	rownames(sub)<-data$Row.names#
#
#	dataafterfit<-rbindlist(list(dataafterfit,sub))#
	dataafterfit<-rbind(dataafterfit,sub)#
#
## save fitted model#
	outfitted<-list(outfitted, temp$fittedModel)#
#
###
	processout<-rbind(processout,c(paste("Finished a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
} ### end protein loop#
#
###
	processout<-rbind(processout,c("Comparisons for all proteins are done.- okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
##### finalize result#
## need to FDR per comparison#
out.all<-NULL#
#
out$Label<-as.character(out$Label)#
for(i in 1:nrow(contrast.matrix)){#
	outsub<-out[out$Label==row.names(contrast.matrix)[i],]#
	outsub<-data.frame(outsub,adj.pvalue=p.adjust(outsub$pvalue,method="BH"))#
#	out.all<-rbindlist(list(out.all, outsub))#
	out.all<-rbind(out.all, outsub)#
#
}#
out.all$Label<-factor(out.all$Label)#
###
	processout<-rbind(processout,c("Adjust p-values per comparison are calculated - okay."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	setnames(out.all,3,"log2FC")	#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	setnames(out.all,3,"log10FC")	#
}#
#
	## change the format as data.frame#
	out.all<-data.frame(out.all)#
#
###
	processout<-rbind(processout,c("Group comparison is done. - okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
finalout<-list(ComparisonResult=out.all, ModelQC=dataafterfit, fittedModel=outfitted)#
return(finalout)	#
#
}
?MSstats.daily
test<-groupComparison(contrast.matrix=comparison, data=QuantData)#
test$ComparisonResult
test2<-groupComparison2(contrast.matrix=comparison, data=QuantData)#
test2$ComparisonResult
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
names(temp)
#########################################################
.fit.model.single<-function(contrast.matrix,data,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup){#
	if(labeled){ ## labeled==TRUE#
# when subject is fixed, it is ok using lm function. When we use lm, model with nested or crossed samples have the same results. In the future, if we want to have sample quantification. We need to separate the cases of nested or crossed samples.#
		### (1) fixed Subject, fixed Run#
		if(scopeOfTechReplication=="restricted" & scopeOfBioReplication=="restricted"){#
			# case-control#
			if (!repeated){	#
				if(TechReplicate){#
					fit.full<-lm(ABUNDANCE ~ SUBJECT_NESTED + GROUP + RUN , data = data)#
#
				}else{#
					fit.full<-lm(ABUNDANCE ~ GROUP + RUN , data = data)#
				}#
			}else{ ### time-course#
				if(TechReplicate){#
					fit.full<-lm(ABUNDANCE ~ SUBJECT_NESTED + GROUP + RUN , data = data)#
#
				}else{#
					fit.full<-lm(ABUNDANCE ~ SUBJECT + GROUP + RUN , data = data)#
				}#
			}#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for comparion#
#
			#finalout<-list(result=allout,summary=fit.full)		#
			#return(finalout)#
		}	### tech replication=restricted#
		### (2) random Subject, fixed Run#
		if(scopeOfTechReplication=="restricted" & scopeOfBioReplication=="expanded"){#
#
			# case-control#
			if (!repeated){	#
				if(TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ (1|SUBJECT_NESTED) + GROUP + RUN , data = data)#
					# calculate DF of SUBJECT_NESTED#
					temp<-unique(data[,c("GROUP","SUBJECT")])#
					temp1<-xtabs(~GROUP,data=temp)#
					df.full<-sum(temp1[-1]-1)	#
				}else{#
					message(paste(unique(data$PROTEIN),"This protein has single feature and no technical replicate. Therefore, we can't analysis with expanded scope of biolofical replication."))#
				}#
			}else{ ### time-course#
				if(TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN , data = data)#
					# calculate DF of SUBJECT:GROUP#
					temp<-unique(data[,c("GROUP","SUBJECT")])#
					temp1<-xtabs(~GROUP,data=temp)#
					df.full<-sum(temp1[-c(1,2)]-1)#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ (1|SUBJECT) + GROUP + RUN , data = data)#
					df.full<-lm(ABUNDANCE ~ SUBJECT + GROUP + RUN , data = data)$df.residual#
				}#
			}#
			## get parameter from model#
			randomPara<-.getParameterRandom(fit.full,df.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(randomPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for comparion#
		} # random subject, fixed run#
		### (3) fixed subject, random Run#
		if(scopeOfTechReplication=="expanded" & scopeOfBioReplication=="restricted"){#
#
			# case-control#
			if (!repeated){	#
				if(TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ SUBJECT_ORIGINAL + GROUP + (1|RUN) , data = data)#
					df.full<-lm(ABUNDANCE ~ SUBJECT_ORIGINAL  + GROUP + RUN , data = data)$df.residual#
#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ GROUP + (1|RUN) , data = data)#
					df.full<-lm(ABUNDANCE ~ GROUP + RUN , data = data)$df.residual#
				}#
			}else{ ### time-course#
				if(TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN) , data = data)#
					df.full<-lm(ABUNDANCE ~ SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + RUN , data = data)$df.residual#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ SUBJECT_ORIGINAL + GROUP + (1|RUN) , data = data)#
					df.full<-lm(ABUNDANCE ~ SUBJECT_ORIGINAL + GROUP + RUN , data = data)$df.residual#
				}#
			}#
			## get parameter from model#
			randomPara<-.getParameterRandom(fit.full,df.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(randomPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for comparion#
		} # random run, fixed subject	#
		### (4) random subject, random Run#
		if(scopeOfTechReplication=="expanded" & scopeOfBioReplication=="expanded"){#
#
			# case-control#
			if (!repeated){	#
				if(TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ (1|SUBJECT_NESTED) + GROUP + (1|RUN) , data = data)#
					# calculate DF of SUBJECT_NESTED#
					temp<-unique(data[,c("GROUP","SUBJECT")])#
					temp1<-xtabs(~GROUP,data=temp)#
					df.full<-sum(temp1[-1]-1)#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ GROUP + (1|RUN) , data = data)#
					df.full<-lm(ABUNDANCE ~ GROUP + RUN , data = data)$df.residual#
				}#
			}else{ ### time-course#
				if(TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN) , data = data)#
					# calculate DF of SUBJECT:GROUP#
					temp<-unique(data[,c("GROUP","SUBJECT")])#
					temp1<-xtabs(~GROUP,data=temp)#
					df.full<-sum(temp1[-c(1,2)]-1)	#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ (1|SUBJECT) + GROUP + (1|RUN) , data = data)#
					# calculate DF of SUBJECT:GROUP#
					temp<-unique(data[,c("GROUP","SUBJECT")])#
					temp1<-xtabs(~GROUP,data=temp)#
					df.full<-sum(temp1[-c(1,2)]-1)#
				}#
			}#
			## get parameter from model#
			randomPara<-.getParameterRandom(fit.full,df.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(randomPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for comparion#
		} # random run, fixed subject	#
	} ## label-based#
## label-free : use only light intensity, need to change contrast.matrix without Group0	#
	if(!labeled){#
		## use only light#
		data2<-subset(data,LABEL=="L")#
		data2$GROUP<-factor(data2$GROUP)#
		data2$SUBJECT<-factor(data2$SUBJECT)#
#
# when subject is fixed, it is ok using lm function.#
#
# when single feature, consider technical replicates for time-course.#
#
		if (scopeOfBioReplication=="restricted"){#
			# case-control: impossible for GROUP+SUBJECT for case-control (parameter for the last SUBJECT is NA even though with technical replicates)#
			if (!repeated){ ## case-control#
				if(!TechReplicate){#
					fit.full<-lm(ABUNDANCE ~ GROUP , data = data2)#
				}else{#
					fit.full<-lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)#
#
				}#
			}else{ ### repeated==TRUE, time-course#
				if(!TechReplicate){#
					fit.full<-lm(ABUNDANCE ~ GROUP+SUBJECT , data = data2)#
				}else{#
					fit.full<-lm(ABUNDANCE ~ GROUP+SUBJECT+GROUP:SUBJECT, data = data2) ## SUBJECT==SUBJECT_NESTED here#
				}#
			} ## time-course#
#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
					out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.free.single(fit.full,contrast.matrix.sub,data2)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
#
		} ## restricted, fixed subject	#
		if(scopeOfBioReplication=="expanded"){#
#
			# case-control#
			if (!repeated){#
				if(!TechReplicate){#
					message("*** error : can't analyze with expanded scope of BioReplicates. Use the restricted scope of BioReplicates")#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ GROUP+(1|SUBJECT) , data = data2)#
					df.full<-lm(ABUNDANCE ~ GROUP+SUBJECT , data = data2)$df.residual#
				}#
#
			}else{ ## time-course#
				if(!TechReplicate){#
					fit.full<-lmer(ABUNDANCE ~ GROUP+(1|SUBJECT) , data = data2)#
					df.full<-lm(ABUNDANCE ~ GROUP+SUBJECT , data = data2)$df.residual#
				}else{#
					fit.full<-lmer(ABUNDANCE ~ GROUP+(1|SUBJECT)+(1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
					df.full<-lm(ABUNDANCE ~ GROUP+SUBJECT+GROUP:SUBJECT , data = data2)$df.residual#
				}#
			} ## time-course#
			## get parameter from model#
			randomPara<-.getParameterRandom(fit.full,df.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.free.single(fit.full,contrast.matrix.sub,data2)#
					out<-.estimableFixedRandom(randomPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for comparion#
#
		}	## expanded, random subject#
#
	} ## label-free#
#
	if(class(fit.full)=="lm"){  ### lm model#
		finalresid<-fit.full$residuals#
		finalfitted<-fit.full$fitted.values#
	}else{   ### lmer model#
		finalresid<-resid(fit.full)#
		finalfitted<-fitted(fit.full)#
	}#
	finalout<-list(result=allout,valueresid=finalresid, valuefitted=finalfitted, fittedmodel=fit.full)	#
	return(finalout)#
} ## .fit.model.single#
#########################################################
.fit.model<-function(contrast.matrix,data,labeled,scopeOfBioReplication,scopeOfTechReplication,interference,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup){#
	nrepeats=3#
	## label-free : use only light intensity, need to change contrast.matrix without Group0	#
	if(!labeled){#
		## use only light#
		data2<-subset(data,LABEL=="L")#
		data2$GROUP<-factor(data2$GROUP)#
		data2$SUBJECT<-factor(data2$SUBJECT)#
#
		# when single subject, there is no need to distinguish case-control and time course; fixed subject or random subject, and no need to have GXF since there is not enough degree of freedom, hence no separatation of interference	#
		if (singleSubject){#
			if(!TechReplicate){#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP , data = data2)#
			}else{#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + GROUP:FEATURE , data = data2)#
			}#
			## make equal variance for feature#
			if(!equalFeatureVar){#
				fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
			}#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", paste(origGroup[GroupComparisonAgreement$positionMiss],collapse=", "), " are missing completely.")#
#
					out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
		} ## singleSubject is TRUE#
#
		if (!singleSubject){#
		# when subject is fixed, it is ok using lm function. When we use lm, model with nested or crossed samples have the same results. In the future, if we want to have sample quantification. We need to separate the cases of nested or crossed samples.#
#
		#===========#
		# (1) Subject:F; case-control/time course#
		# since it's fixed effect model, the results of nested model and crossed model are the same#
		# but when there is unequal subject, the SE is slightly different#
		# also no missing patterns (GXF, G, S) will stop the test#
		#==========	#
			if (scopeOfBioReplication=="restricted"){#
				# case-control#
				if (!repeated){	#
					if(interference){#
     					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data2)#
					}else{#
	  					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP, data = data2)#
					}#
				}else{	## time-course#
					if(interference){#
      					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data2)#
      					#fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + SUBJECT:GROUP + GROUP + FEATURE:GROUP , data = data2)#
					}else{#
	  					fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP, data = data2)#
	  					#fit.full<-lm(ABUNDANCE ~ FEATURE + SUBJECT + SUBJECT:GROUP + GROUP, data = data2)#
#
					}#
				}#
	     		## make equal variance for feature#
	     		if(!equalFeatureVar){#
	     			fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
	     		}#
				## get parameter from model before all comparison#
				fixedPara<-.getParameterFixed(fit.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
						out<-.estimableFixedRandom(fixedPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)#
				} # end loop for contrast#
#
			} ## bioRep is restricted#
	#===========#
	# (2) Subject:R; #
	# since it's mixed effect model, the results of nested model and crossed model are not the same#
	# df of nested and crossed are not the same as well.#
	# also missing patterns (GXF) will stop the test, but (G, S) will not#
	#==========	#
			if (scopeOfBioReplication=="expanded"){#
#
				# case-control#
				if (!repeated){#
					if(interference){#
						if(!MissGroupByFeature){#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1-1)#
      					}else{  ## MissGroupByFeature==TRUE#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP, data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1-1)#
      					}#
					}else{ ## interference==FALSE#
	  					fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP, data = data2)#
	  					temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  					temp1<-xtabs(~GROUP,data=temp)#
      					df.full<-sum(temp1-1)#
					}#
				}else{  ##time-course#
					if(interference){#
						if(!MissGroupByFeature){#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + FEATURE:GROUP , data = data2)#
      						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1[-1]-1)#
      					}else{ ## MissGroupByFeature==TRUE#
							# SE is slightly different	#
      						fit.full<-lmer(ABUNDANCE ~ FEATURE +   (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP, data = data2)#
     						temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  						temp1<-xtabs(~GROUP,data=temp)#
      						df.full<-sum(temp1[-1]-1)#
      					}#
					}else{  ## interference==FALSE#
	  					fit.full<-lmer(ABUNDANCE ~ FEATURE +   (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP, data = data2)#
	  					temp<-unique(data2[,c("GROUP","SUBJECT")])#
	  					temp1<-xtabs(~GROUP,data=temp)#
      					df.full<-sum(temp1[-1]-1)#
					}#
				}#
	     		## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data2,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data2,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.free(fit.full,contrast.matrix.sub,data2)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data2$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)#
				} # end loop for contrast#
			}## bio rep is expanded#
#
		}## singleSub=FALSE#
#
	} ## label -free	#
	if(labeled){	#
	# when single subject, there is no need to distinguish case-control and time course; fixed subject or random subject, and no need to have GXF RXF since there is not enough degree of freedom, hence no separatation of interference	#
		if (singleSubject){#
			message(paste("*** ",unique(data$PROTEIN)," has single subject per condition. Only restricted scope of conclusion is possible."))#
			if(TechReplicate){#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + RUN + GROUP:FEATURE + RUN:FEATURE, data = data)#
			}else{#
				fit.full<-lm(ABUNDANCE ~ FEATURE + GROUP + RUN, data = data)#
			}#
	     	## make equal variance for feature#
	     	if(!equalFeatureVar){#
	   			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
	   		}#
			## get parameter from model#
			fixedPara<-.getParameterFixed(fit.full)#
			#### each comparison#
			allout<-NULL#
			for(k in 1:nrow(contrast.matrix)){#
				# choose each comparison#
				contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
				row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
				GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
				if(GroupComparisonAgreement$sign==TRUE){#
					message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
					out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
				}else{#
					contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
					out<-.estimableFixedRandom(fixedPara,contrast)#
					## any error for out, just NA#
					if(is.null(out)){#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
					}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
					}#
				}#
				allout<-rbind(allout, out)#
			} # end loop for contrast#
#
		} ## singleSub is True#
#
		if (!singleSubject){#
		##########################	#
		# (1) Subject: F, Run: F#
		##########################	#
#
			if(scopeOfBioReplication=="restricted" & scopeOfTechReplication=="restricted"){#
				## (1.1) case-control#
				if (!repeated){#
					if(interference){#
						fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
					}else{#
						fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + RUN, data = data)#
					}#
				}else{  ## (1.2) time-course#
					if(interference){#
						fit.full<-lm(ABUNDANCE ~ FEATURE  +  SUBJECT_NESTED + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
					}else{#
						fit.full<-lm(ABUNDANCE ~ FEATURE  +  SUBJECT_NESTED  + GROUP + RUN, data = data)#
					}#
				}	#
		     	## make equal variance for feature#
	     		if(!equalFeatureVar){#
	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
	     		}#
				## get parameter from model#
				fixedPara<-.getParameterFixed(fit.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(fixedPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			} ## fSfR#
		##########################	#
		# (2) Subject: R, Run: F#
		##########################	#
#
			if(scopeOfBioReplication=="expanded"&scopeOfTechReplication=="restricted"){#
				## (2.1) case-control#
				if (!repeated){#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN, data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)		#
						}#
					}else{ ##interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + RUN, data = data)#
						# calculate DF of SUBJECT_NESTED#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-1]-1)#
					}#
				}else{  ## (2.2) time-course#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + RUN, data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)	#
						}#
					}else{  ##interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + RUN, data = data)#
						# calculate DF of SUBJECT:GROUP#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-c(1,2)]-1)#
					}	#
				}#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}	#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			}	#rSfR#
		##########################	#
		# (3) Subject: F, Run: R#
		# only SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP can work for model fitting#
		# therefore, there is no need to separate case-control and time course#
		# however, when there is unequal subject, we need to fit additive model of removing SUBJECT by GROUP#
		##########################	#
#
			if(scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
				## (3.1) equal subject per group#
				if (!UnequalSubject){#
					if(interference){#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)$df.residual#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
						}#
					}else{  ## interference#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + SUBJECT_ORIGINAL:GROUP + GROUP + (1|RUN), data = data)#
						df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
					}#
				}else{ ## (3.2) unequal subject per group#
					if(interference){		#
						if(!MissGroupByFeature & !MissRunByFeature){#
#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN + FEATURE:GROUP +  FEATURE:RUN, data = data)$df.residual#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL  + GROUP + (1|RUN), data = data)#
							df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT  + RUN, data = data)$df.residual#
						}			#
					}else{ ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  SUBJECT_ORIGINAL  + GROUP + (1|RUN), data = data)#
						df.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT + GROUP + GROUP:SUBJECT + RUN, data = data)$df.residual#
					}#
				}	#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison#
			} #fSrR	#
		##########################	#
		# (4) Subject: R, Run: R#
		##########################	#
#
			if(scopeOfBioReplication=="expanded" & scopeOfTechReplication=="expanded"){#
				## (4.1) case-control#
				if (!repeated){#
					if(interference){#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED)  + GROUP + (1|RUN), data = data)#
							# calculate DF of SUBJECT_NESTED#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-1]-1)#
						}#
					}else{ ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + (1|RUN), data = data)#
						# calculate DF of SUBJECT_NESTED#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-1]-1)#
					}#
				}else{  ## (4.2) time-course#
					if(interference){	#
						if(!MissGroupByFeature & !MissRunByFeature){#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN) + FEATURE:GROUP +  (1|FEATURE:RUN), data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}else{#
							fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP) + GROUP + (1|RUN), data = data)#
							# calculate DF of SUBJECT:GROUP#
							temp<-unique(data[,c("GROUP","SUBJECT")])#
							temp1<-xtabs(~GROUP,data=temp)#
							df.full<-sum(temp1[-c(1,2)]-1)#
						}#
					}else{  ## interference==FALSE#
						fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT) + (1|SUBJECT:GROUP)  + GROUP + (1|RUN), data = data)#
						# calculate DF of SUBJECT:GROUP#
						temp<-unique(data[,c("GROUP","SUBJECT")])#
						temp1<-xtabs(~GROUP,data=temp)#
						df.full<-sum(temp1[-c(1,2)]-1)#
					}#
				}	#
		     	## make equal variance for feature#
#	     		if(!equalFeatureVar){#
#	     			fit.full<-.iter.wls.fit.model(data=data,fit=fit.full,nrepeats)#
#	     		}#
				## get parameter from model#
				randomPara<-.getParameterRandom(fit.full,df.full)#
				#### each comparison#
				allout<-NULL#
				for(k in 1:nrow(contrast.matrix)){#
					# choose each comparison#
					contrast.matrix.sub<-matrix(contrast.matrix[k,], nrow=1)#
					row.names(contrast.matrix.sub)<-row.names(contrast.matrix)[k]#
					GroupComparisonAgreement<-.chechGroupComparisonAgreement(data,contrast.matrix.sub)#
#
					if(GroupComparisonAgreement$sign==TRUE){#
						message("*** error : results of Protein ", unique(data$PROTEIN), " for comparison ",row.names(contrast.matrix.sub), " are NA because measurements in Group ", origGroup[GroupComparisonAgreement$positionMiss], " are missing completely.")#
#
						out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)		#
					}else{#
						contrast<-.make.contrast.based(fit.full,contrast.matrix.sub,data)#
						out<-.estimableFixedRandom(randomPara,contrast)#
						## any error for out, just NA#
						if(is.null(out)){#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub), logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA)#
						}else{#
							out<-data.frame(Protein=unique(data$PROTEIN),Label=row.names(contrast.matrix.sub),out)	#
						}#
					}#
					allout<-rbind(allout, out)	#
				} # end loop for comparison	#
			} #rSrR		#
		} ## singleSub is FALSE#
	}## label-based#
	if(class(fit.full)=="lm"){  ### lm model#
		finalresid<-fit.full$residuals#
		finalfitted<-fit.full$fitted.values#
	}else{   ### lmer model#
		finalresid<-resid(fit.full)#
		finalfitted<-fitted(fit.full)#
	}#
	finalout<-list(result=allout,valueresid=finalresid, valuefitted=finalfitted, fittedmodel=fit.full)	#
#
	return(finalout)#
}
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
names(temp)
temp$fittedmodel
class(temp)=="try-error"
tempresult<-temp
out<-rbind(out,tempresult$result)
out
if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}
head(sub)
dataafterfit<-rbind(dataafterfit,sub)
head(dataafterfit)
outfitted<NULL
outfitted<-NULL
outfitted<-list(outfitted, tempresult$fittedmodel)
outfitted
out.all<-NULL#
#
out$Label<-as.character(out$Label)#
for(i in 1:nrow(contrast.matrix)){#
	outsub<-out[out$Label==row.names(contrast.matrix)[i],]#
	outsub<-data.frame(outsub,adj.pvalue=p.adjust(outsub$pvalue,method="BH"))#
#	out.all<-rbindlist(list(out.all, outsub))#
	out.all<-rbind(out.all, outsub)#
#
}#
out.all$Label<-factor(out.all$Label)
out.all
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	setnames(out.all,3,"log2FC")	#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	setnames(out.all,3,"log10FC")	#
}
test
head(test)
test$ComparisonResult
temp<-data[!is.na(data[,"ABUNDANCE"]),]
head(temp)
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	setNames(out.all,3,"log2FC")	#
}
out.all
abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"]
)
abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log2FC"#
}
out.all
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log2FC"#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log10FC"#
}
out.all<-data.frame(out.all)
finalout<-list(ComparisonResult=out.all, ModelQC=dataafterfit, fittedmodel=outfitted)
groupComparison2<-function(contrast.matrix=contrast.matrix,data=data,labeled=TRUE, scopeOfBioReplication="restricted", scopeOfTechReplication="expanded", interference=TRUE,equalFeatureVar=TRUE,missing.action = "nointeraction"){#
#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile, header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - groupComparison function"," "),ncol=1))#
	## check input is correct#
	## data format#
	rawinput<-c("ProteinName","PeptideSequence","PrecursorCharge","FragmentIon","ProductCharge","IsotopeLabelType","Condition","BioReplicate","Run","Intensity")#
	if(length(setdiff(toupper(rawinput),toupper(colnames(data))))==0){#
		processout<-rbind(processout,c(paste("The required input - data : did not process from dataProcess function. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("Please use 'dataProcess' first. Then use output of dataProcess function as input in groupComparison.")#
	}#
	## contrast. matrix#
	if(ncol(contrast.matrix)!=length(unique(data$GROUP_ORIGINAL))){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: the number of column and the number of group are not the same. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("Please check contrast matrix. The number of group in data set is different with columns of contrast.matrix.")#
	}#
	# check whether row.names of contrast.matrix.sub exists or not#
	if(sum(is.null(row.names(contrast.matrix)))>0){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: need row names of contrast.matrix . - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("No row.names of comparison exist.\n")#
	}#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(sum(unique(data$LABEL) %in% "H")==0 & labeled==TRUE){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. labeled should be 'FALSE'. Therefore now use labeled=FALSE")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 message("Dataset is based on label-free experiment. MSstats will use \"labeled\"=FALSE.")#
		 labeled<-FALSE#
	}#
	## other option value#
	if(!(scopeOfTechReplication=="restricted" | scopeOfTechReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfTechReplication : 'scopeOfTechReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfTechReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	}#
	if(!(scopeOfBioReplication=="restricted" | scopeOfBioReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfBioReplication : 'scopeOfBioReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfBioReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	} #
	if(!(interference==TRUE | interference==FALSE) | !is.logical(interference)){#
		processout<-rbind(processout,c(paste("The required input - interference : 'interference' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'interference' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(!(equalFeatureVar==TRUE | equalFeatureVar==FALSE) | !is.logical(equalFeatureVar)){#
		processout<-rbind(processout,c(paste("The required input - equalFeatureVar : 'equalFeatureVar' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("'equalFeatureVar' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(equalFeatureVar==FALSE & (scopeOfBioReplication=="expanded" | scopeOfTechReplication=="expanded")){#
		message("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication.")#
		processout<-rbind(processout,c("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication."))#
		write.table(processout, file=finalfile, row.names=FALSE)#
	}#
	if(!(missing.action %in% c("nointeraction", "impute", "remove"))){#
		processout<-rbind(processout,c(paste("The required input - missing.action : 'missing.action' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'missing.action' must be one of \"nointeraction\", \"impute\", or \"remove\".")#
	}#
#
	## all input#
		processout<-rbind(processout,c(paste("labeled = ",labeled,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfBioReplication = ",scopeOfBioReplication,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfTechReplication = ", scopeOfTechReplication,sep="")))#
		processout<-rbind(processout,c(paste("interference = ",interference,sep="")))#
		processout<-rbind(processout,c(paste("equalFeatureVar = ",equalFeatureVar,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
## check whether case-control(FALSE) or time-course(TRUE)#
repeated<-.checkRepeated(data)#
#
	if(repeated){ #
		processout<-rbind(processout,c(paste("Time course design of experiment - okay")))#
	}else{#
		processout<-rbind(processout,c(paste("Case control design of experiment - okay")))#
#
	}#
	write.table(processout, file=finalfile, row.names=FALSE)#
## since case-control(FALSE) with fixed subject and random run will fit the crossed model#
# we need to set subject_original to non-unique#
#
if(repeated==FALSE&scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
	test<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	test<- test[with(test, order(GROUP_ORIGINAL,SUBJECT_ORIGINAL)),]#
	test$GROUP_ORIGINAL<-factor(test$GROUP_ORIGINAL)#
	test1<-as.matrix(xtabs(~test[,1]))#
	test$SUBJECT_ORIGINAL_NOUNIQUE<-as.numeric(unlist(apply(test1,1,function(x) seq(x))))#
#
	data$SUBJECT_ORIGINAL<-as.character(data$SUBJECT_ORIGINAL)#
#
	for (i in 1:length(unique(test$SUBJECT_ORIGINAL_NOUNIQUE))){#
		list<-test$SUBJECT_ORIGINAL[test$SUBJECT_ORIGINAL_NOUNIQUE==i]#
		data$SUBJECT_ORIGINAL[data$SUBJECT_ORIGINAL%in%list]<-i	#
	}#
#
	data$SUBJECT_ORIGINAL<-factor(data$SUBJECT_ORIGINAL)#
}#
data$PROTEIN<-factor(data$PROTEIN)	#
#
## for final result report#
out<-NULL#
outsummary<-NULL#
outfitted<-NULL#
dataafterfit<-NULL#
#
##################################
### how to handle missingness for endogenous#
#
data.l<-data[data$LABEL=="L",]#
data.h<-data[data$LABEL=="H",]#
#
missingPeptides<-.checkMissFeature(data.l)#
#
protein.list = tapply ( data.l$FEATURE, data.l$PROTEIN, function ( x ) unique ( as.character ( x ) ) )#
#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
## Impute for missing endogenous intensity#
if ( missing.action == "impute" ) { #
	if(length(missingPeptides) > 0){#
		dataBySample <- tapply(data.l$ABUNDANCE, list(data.l$SUBJECT_ORIGINAL, data.l$FEATURE), function(x) min(x, na.rm = TRUE))#
		dataBySample <- dataBySample[!(apply(dataBySample, 1, function(x) sum(is.na(x))) == ncol(dataBySample)), ]#
#
		if(!is.numeric(dataBySample)){ ## only one subject#
			minValuePerSample <- apply(dataBySample, 1, function(x) min(x, na.rm = TRUE))#
		}else{#
			minValuePerSample<-min(dataBySample, na.rm=TRUE)#
		}#
		imputeValue <- mean(minValuePerSample[!is.infinite(minValuePerSample)], na.rm = TRUE)#
#
		for(i in 1:length(missingPeptides)){#
			sub <- data.l[data.l$FEATURE == missingPeptides[i], ]#
			t <- tapply(sub$ABUNDANCE, sub$GROUP, function(x) sum(x > 0, na.rm = TRUE))#
			missingConds <- names(t)[which(t == 0 | is.na(t))]		#
			data.l[data.l$FEATURE %in% missingPeptides[i] & data.l$GROUP %in% missingConds, ]$ABUNDANCE <- imputeValue#
		}#
#
		if(length(missingPeptides) > 0){#
			number.missing <- length(missingPeptides)#
			message(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = ""))	#
			processout<-rbind(processout,c(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = "")))#
			write.table(processout, file=finalfile, row.names=FALSE)	#
		}#
	}#
#	data<-rbindlist(list(data.l,data.h))#
	data<-rbind(data.l,data.h)#
#
}#
## even though it is not the case, user can do with no interaction ( no else command)#
## #
if ( missing.action == "remove" ){#
	data<-data[-which(data$FEATURE %in% missingPeptides),]#
#
	message("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model.")#
	processout<-rbind(processout,c("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
#
}#
## for assigning interference#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
#
###
	processout<-rbind(processout,c(paste("missing.action : ",missing.action," - okay",sep="")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
###==================================================#
### start to analyze by protein ID#
#
	### need original group information#
	origGroup<-unique(data$GROUP_ORIGINAL)#
for (i in 1:nlevels(data$PROTEIN)){#
#
	sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)#
	## need to assigning whether interaction term is included or not#
	remove.interaction<-interference#
if ( missing.action == "nointeraction" & missing.results [ i ]){#
	remove.interaction = FALSE#
	message("** ",paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = ""))#
	processout<-rbind(processout,c(paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = "")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
}#
#
	message(paste("Testing a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")"))#
	if(singleFeature){#
		message("** Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted.")#
		processout<-rbind(processout,c(paste("Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		temp<-try(.fit.model.single(contrast.matrix,sub,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup),silent=TRUE)#
#
	}	#
	if(!singleFeature){#
#
# not sure it is correct and what it means#
#	noRunFeature<-.checkRunbyFeature(sub)#
#	if(noRunFeature) unbalanced=TRUE#
	temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)#
#
	}#
## fix(apr 16)#
	if(class(temp)=="try-error") {#
		message("*** error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.")#
		processout<-rbind(processout,c(paste("error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		tempresult<-list(result=NULL,valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
		for(k in 1:nrow(contrast.matrix)){	#
			tempresult$result<-rbind(tempresult$result, data.frame(Protein=levels(data$PROTEIN)[i],Label=row.names(contrast.matrix)[k], logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA))#
		}#
	}else{#
		tempresult<-temp#
	}#
#
## comparison result table#
#	out<-rbindlist(list(out,tempresult$result))#
	out<-rbind(out,tempresult$result)#
#
## for checking model assumptions#
## add residual and fitted after fitting the model#
	if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}#
	## order concerned#
#	residuals<-data.frame(temp$valueresid)#
#	fitted<-data.frame(temp$valuefitted)#
#	sub<-merge(sub,residuals,by="row.names",all=T)#
#	rownames(sub)<-sub$Row.names#
#	sub<-merge(sub, fitted, by="row.names",all=T)#
#	rownames(sub)<-data$Row.names#
#
#	dataafterfit<-rbindlist(list(dataafterfit,sub))#
	dataafterfit<-rbind(dataafterfit,sub)#
#
## save fitted model#
	outfitted<-list(outfitted, tempresult$fittedmodel)#
#
###
	processout<-rbind(processout,c(paste("Finished a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
} ### end protein loop#
#
###
	processout<-rbind(processout,c("Comparisons for all proteins are done.- okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
##### finalize result#
## need to FDR per comparison#
out.all<-NULL#
#
out$Label<-as.character(out$Label)#
for(i in 1:nrow(contrast.matrix)){#
	outsub<-out[out$Label==row.names(contrast.matrix)[i],]#
	outsub<-data.frame(outsub,adj.pvalue=p.adjust(outsub$pvalue,method="BH"))#
#	out.all<-rbindlist(list(out.all, outsub))#
	out.all<-rbind(out.all, outsub)#
#
}#
out.all$Label<-factor(out.all$Label)#
###
	processout<-rbind(processout,c("Adjust p-values per comparison are calculated - okay."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log2FC"#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log10FC"#
}#
#
	## change the format as data.frame#
	out.all<-data.frame(out.all)#
#
###
	processout<-rbind(processout,c("Group comparison is done. - okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
finalout<-list(ComparisonResult=out.all, ModelQC=dataafterfit, fittedmodel=outfitted)#
return(finalout)	#
#
}
test2<-groupComparison2(contrast.matrix=comparison, data=QuantData)#
test2$ComparisonResult
test<-groupComparison(contrast.matrix=comparison, data=QuantData)#
test$ComparisonResult
names(test)
names(test2)
test2$fittedmodel
names(test2)
length(test2$fittedmodel)
data<-test2$fittedmodel
i=1
data[[i]]
?designSampleSize
designSampleSize(data=QuantData,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
designSampleSize2<-function(data=data,labeled=TRUE,numSample=numSample,numPep=numPep,numTran=numTran,desiredFC=desiredFC,FDR=0.05,power=0.9,scopeOfBioReplication="restricted",interference=TRUE,equalFeatureVar=TRUE){#
#
	nrepeats=3#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile,header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - designSampleSize function"," "),ncol=1))#
	## check one TRUE or not#
	if( sum(isTRUE(numSample),isTRUE(numPep),isTRUE(numTran),isTRUE(power))!=1 ){#
		processout<-rbind(processout,c(paste("The required input - number of sample or features : Only one value should be TRUE. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("One of (numSample, numPep, numTran, power) needs to be TRUE")#
	}#
#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	## all input#
		processout<-rbind(processout,c(paste("number of sample = ",numSample,sep="")))#
		processout<-rbind(processout,c(paste("number of peptide per protein = ",numPep,sep="")))#
		processout<-rbind(processout,c(paste("number of transition per peptide = ", numTran,sep="")))#
		processout<-rbind(processout,c(paste("Desired fold change = ",paste(desiredFC,collapse=" - "),sep="")))#
		processout<-rbind(processout,c(paste("FDR = ",FDR,sep="")))#
		processout<-rbind(processout,c(paste("Power = ", power,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
	## for label-free experiment#
	if (!labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=levels(data$PROTEIN),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.na(fit.full)) {#
					next#
				}else{#
					## get variance component#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
#		VarComponent[is.na(VarComponent)]<-0	#
		## for label-free DDA, there are lots of missingness and lots of zero SE. So, remove NA SE.#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(!is.na(VarComponent[,"GroupBySubject"]))>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			if(sum(!is.na(VarComponent[,"Subject"]))>0){#
				median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
			}else{#
				median.sigma.subject<-0#
			}#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt(2*median.sigma.error/numPep/numTran/numSample+median.sigma.subject/numSample)#
   			 powerTemp<-seq(0,1,0.01)#
    		power<-NULL#
   			for(i in 1:length(t)){#
    			diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
    			min(abs(diff),na.rm=TRUE)#
    			power[i]<-powerTemp[order(abs(diff))][1]#
    		}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
    		####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
    		out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if (isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round((2*median.sigma.error/numPep/numTran+median.sigma.subject)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if (isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((2*median.sigma.error/numSample/numTran+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if (isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((2*median.sigma.error/numSample/numPep+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # when power is numeric#
	} ## label-free#
	## isotope labeled experiment#
	if (labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=levels(data$PROTEIN),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.na(fit.full)) {#
					next#
#
				}else{#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
		## label-based case, few of NA SE.#
		VarComponent[is.na(VarComponent)]<-0	#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(VarComponent[,"GroupBySubject"])>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt((4*median.sigma.error/numPep/numTran/numSample)+(2*median.sigma.subject/numSample))#
			powerTemp<-seq(0,1,0.01)#
			power<-NULL#
			for(i in 1:length(t)){#
				diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
				min(abs(diff),na.rm=TRUE)#
				power[i]<-powerTemp[order(abs(diff))][1]#
			}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
        	####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
  			out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if(isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round(((4*median.sigma.error/numPep/numTran)+(2*median.sigma.subject))/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+(2*median.sigma.subject/numSample))/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if(isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((4*median.sigma.error/numSample/numTran+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if(isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((4*median.sigma.error/numSample/numPep+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # power is numeric#
	} ## label-based#
}
designSampleSize(data=QuantData,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
designSampleSize2(data=test2$fittedmodel,labeled=TRUE,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
names(test2$fittedmodel)
test2$fittedmodel
seq(1,length(test2$fittedmodel))
designSampleSize2<-function(data=data,labeled=TRUE,numSample=numSample,numPep=numPep,numTran=numTran,desiredFC=desiredFC,FDR=0.05,power=0.9,scopeOfBioReplication="restricted",interference=TRUE,equalFeatureVar=TRUE){#
#
	nrepeats=3#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile,header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - designSampleSize function"," "),ncol=1))#
	## check one TRUE or not#
	if( sum(isTRUE(numSample),isTRUE(numPep),isTRUE(numTran),isTRUE(power))!=1 ){#
		processout<-rbind(processout,c(paste("The required input - number of sample or features : Only one value should be TRUE. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("One of (numSample, numPep, numTran, power) needs to be TRUE")#
	}#
#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	## all input#
		processout<-rbind(processout,c(paste("number of sample = ",numSample,sep="")))#
		processout<-rbind(processout,c(paste("number of peptide per protein = ",numPep,sep="")))#
		processout<-rbind(processout,c(paste("number of transition per peptide = ", numTran,sep="")))#
		processout<-rbind(processout,c(paste("Desired fold change = ",paste(desiredFC,collapse=" - "),sep="")))#
		processout<-rbind(processout,c(paste("FDR = ",FDR,sep="")))#
		processout<-rbind(processout,c(paste("Power = ", power,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
	## for label-free experiment#
	if (!labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.na(fit.full)) {#
					next#
				}else{#
					## get variance component#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
#		VarComponent[is.na(VarComponent)]<-0	#
		## for label-free DDA, there are lots of missingness and lots of zero SE. So, remove NA SE.#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(!is.na(VarComponent[,"GroupBySubject"]))>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			if(sum(!is.na(VarComponent[,"Subject"]))>0){#
				median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
			}else{#
				median.sigma.subject<-0#
			}#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt(2*median.sigma.error/numPep/numTran/numSample+median.sigma.subject/numSample)#
   			 powerTemp<-seq(0,1,0.01)#
    		power<-NULL#
   			for(i in 1:length(t)){#
    			diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
    			min(abs(diff),na.rm=TRUE)#
    			power[i]<-powerTemp[order(abs(diff))][1]#
    		}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
    		####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
    		out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if (isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round((2*median.sigma.error/numPep/numTran+median.sigma.subject)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if (isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((2*median.sigma.error/numSample/numTran+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if (isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((2*median.sigma.error/numSample/numPep+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # when power is numeric#
	} ## label-free#
	## isotope labeled experiment#
	if (labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.na(fit.full)) {#
					next#
#
				}else{#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
		## label-based case, few of NA SE.#
		VarComponent[is.na(VarComponent)]<-0	#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(VarComponent[,"GroupBySubject"])>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt((4*median.sigma.error/numPep/numTran/numSample)+(2*median.sigma.subject/numSample))#
			powerTemp<-seq(0,1,0.01)#
			power<-NULL#
			for(i in 1:length(t)){#
				diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
				min(abs(diff),na.rm=TRUE)#
				power[i]<-powerTemp[order(abs(diff))][1]#
			}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
        	####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
  			out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if(isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round(((4*median.sigma.error/numPep/numTran)+(2*median.sigma.subject))/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+(2*median.sigma.subject/numSample))/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if(isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((4*median.sigma.error/numSample/numTran+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if(isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((4*median.sigma.error/numSample/numPep+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # power is numeric#
	} ## label-based#
}
designSampleSize2(data=test2$fittedmodel,labeled=TRUE,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
data<-test2$fittedmodel
data
sigma.error<-NULL
VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)
VarComponent
i=1
fit.full<-data[[i]]
fit.full
if(class(fit.full)!="mer"){
)
class(fit.full)!="mer"
VarComponent[i,"Error"]<-summary(fit.full)$sigma^2
summary(fit.full)
summary(fit.full)$sigma
head(sub)
fit.full<-lm(ABUNDANCE ~ FEATURE +  SUBJECT_NESTED + GROUP + FEATURE:GROUP , data = data)
fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data)
sub<-QuantData[QuantData$PROTEIN=="IDHC",]
head(sub)
data<-sub
fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data)
summary(fit.full)
names(fit.full)
data<-test2$fittedmodel
head(data)
fit.full<-data[[i]]
fit.full
summary(fit.full)
fit.full$sigma^2
fit.full<-lmer(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data)
fit.full<-lm(ABUNDANCE ~ FEATURE +  (1|SUBJECT_NESTED) + GROUP + FEATURE:GROUP , data = data)
summary(fit.full)$sigma^2
names(fit.full)
data<-QuantData
i=1
sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
names(temp)
temp$fittedmodel
summary(temp$fittedmodel)
summary(temp$fittedmodel)$sigma
names(temp$fittedmodel)
attributes(temp$fittedmodel)
tempresult<-temp
tempresult$fittedmodel
summary(tempresul$fittedmodel)
summary(tempresult$fittedmodel)
summary(tempresult$fittedmodel)$sigma
outfitted<-NULL
outfitted
outfitted<-list(outfitted, tempresult$fittedmodel)
length(outfitted)
outfitted
abc<-outfitted[[2]]
abc
summary(abc)
summary(abc)$sigma
i=2
sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)
temp<-try(.fit.model.single(contrast.matrix,sub,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup),silent=TRUE)
temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)
tempresult<-temp
out<-rbind(out,tempresult$result)
if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}
outfitted<-list(outfitted, tempresult$fittedmodel)
length(outfitted)
outfitted
outfitted<-NULL
outfitted
outfitted<-c(outfitted, list(tempresult$fittedmodel))
length(outfitted)
outfitted
outfitted<-c(outfitted, list(tempresult$fittedmodel))
length(outfitted)
outfitted
summary(outfitted[[2]])
summary(outfitted[[2]])$sigma
groupComparison2<-function(contrast.matrix=contrast.matrix,data=data,labeled=TRUE, scopeOfBioReplication="restricted", scopeOfTechReplication="expanded", interference=TRUE,equalFeatureVar=TRUE,missing.action = "nointeraction"){#
#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile, header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - groupComparison function"," "),ncol=1))#
	## check input is correct#
	## data format#
	rawinput<-c("ProteinName","PeptideSequence","PrecursorCharge","FragmentIon","ProductCharge","IsotopeLabelType","Condition","BioReplicate","Run","Intensity")#
	if(length(setdiff(toupper(rawinput),toupper(colnames(data))))==0){#
		processout<-rbind(processout,c(paste("The required input - data : did not process from dataProcess function. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("Please use 'dataProcess' first. Then use output of dataProcess function as input in groupComparison.")#
	}#
	## contrast. matrix#
	if(ncol(contrast.matrix)!=length(unique(data$GROUP_ORIGINAL))){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: the number of column and the number of group are not the same. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("Please check contrast matrix. The number of group in data set is different with columns of contrast.matrix.")#
	}#
	# check whether row.names of contrast.matrix.sub exists or not#
	if(sum(is.null(row.names(contrast.matrix)))>0){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: need row names of contrast.matrix . - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("No row.names of comparison exist.\n")#
	}#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(sum(unique(data$LABEL) %in% "H")==0 & labeled==TRUE){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. labeled should be 'FALSE'. Therefore now use labeled=FALSE")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 message("Dataset is based on label-free experiment. MSstats will use \"labeled\"=FALSE.")#
		 labeled<-FALSE#
	}#
	## other option value#
	if(!(scopeOfTechReplication=="restricted" | scopeOfTechReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfTechReplication : 'scopeOfTechReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfTechReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	}#
	if(!(scopeOfBioReplication=="restricted" | scopeOfBioReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfBioReplication : 'scopeOfBioReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfBioReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	} #
	if(!(interference==TRUE | interference==FALSE) | !is.logical(interference)){#
		processout<-rbind(processout,c(paste("The required input - interference : 'interference' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'interference' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(!(equalFeatureVar==TRUE | equalFeatureVar==FALSE) | !is.logical(equalFeatureVar)){#
		processout<-rbind(processout,c(paste("The required input - equalFeatureVar : 'equalFeatureVar' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("'equalFeatureVar' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(equalFeatureVar==FALSE & (scopeOfBioReplication=="expanded" | scopeOfTechReplication=="expanded")){#
		message("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication.")#
		processout<-rbind(processout,c("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication."))#
		write.table(processout, file=finalfile, row.names=FALSE)#
	}#
	if(!(missing.action %in% c("nointeraction", "impute", "remove"))){#
		processout<-rbind(processout,c(paste("The required input - missing.action : 'missing.action' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'missing.action' must be one of \"nointeraction\", \"impute\", or \"remove\".")#
	}#
#
	## all input#
		processout<-rbind(processout,c(paste("labeled = ",labeled,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfBioReplication = ",scopeOfBioReplication,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfTechReplication = ", scopeOfTechReplication,sep="")))#
		processout<-rbind(processout,c(paste("interference = ",interference,sep="")))#
		processout<-rbind(processout,c(paste("equalFeatureVar = ",equalFeatureVar,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
## check whether case-control(FALSE) or time-course(TRUE)#
repeated<-.checkRepeated(data)#
#
	if(repeated){ #
		processout<-rbind(processout,c(paste("Time course design of experiment - okay")))#
	}else{#
		processout<-rbind(processout,c(paste("Case control design of experiment - okay")))#
#
	}#
	write.table(processout, file=finalfile, row.names=FALSE)#
## since case-control(FALSE) with fixed subject and random run will fit the crossed model#
# we need to set subject_original to non-unique#
#
if(repeated==FALSE&scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
	test<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	test<- test[with(test, order(GROUP_ORIGINAL,SUBJECT_ORIGINAL)),]#
	test$GROUP_ORIGINAL<-factor(test$GROUP_ORIGINAL)#
	test1<-as.matrix(xtabs(~test[,1]))#
	test$SUBJECT_ORIGINAL_NOUNIQUE<-as.numeric(unlist(apply(test1,1,function(x) seq(x))))#
#
	data$SUBJECT_ORIGINAL<-as.character(data$SUBJECT_ORIGINAL)#
#
	for (i in 1:length(unique(test$SUBJECT_ORIGINAL_NOUNIQUE))){#
		list<-test$SUBJECT_ORIGINAL[test$SUBJECT_ORIGINAL_NOUNIQUE==i]#
		data$SUBJECT_ORIGINAL[data$SUBJECT_ORIGINAL%in%list]<-i	#
	}#
#
	data$SUBJECT_ORIGINAL<-factor(data$SUBJECT_ORIGINAL)#
}#
data$PROTEIN<-factor(data$PROTEIN)	#
#
## for final result report#
out<-NULL#
outsummary<-NULL#
outfitted<-NULL#
dataafterfit<-NULL#
#
##################################
### how to handle missingness for endogenous#
#
data.l<-data[data$LABEL=="L",]#
data.h<-data[data$LABEL=="H",]#
#
missingPeptides<-.checkMissFeature(data.l)#
#
protein.list = tapply ( data.l$FEATURE, data.l$PROTEIN, function ( x ) unique ( as.character ( x ) ) )#
#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
## Impute for missing endogenous intensity#
if ( missing.action == "impute" ) { #
	if(length(missingPeptides) > 0){#
		dataBySample <- tapply(data.l$ABUNDANCE, list(data.l$SUBJECT_ORIGINAL, data.l$FEATURE), function(x) min(x, na.rm = TRUE))#
		dataBySample <- dataBySample[!(apply(dataBySample, 1, function(x) sum(is.na(x))) == ncol(dataBySample)), ]#
#
		if(!is.numeric(dataBySample)){ ## only one subject#
			minValuePerSample <- apply(dataBySample, 1, function(x) min(x, na.rm = TRUE))#
		}else{#
			minValuePerSample<-min(dataBySample, na.rm=TRUE)#
		}#
		imputeValue <- mean(minValuePerSample[!is.infinite(minValuePerSample)], na.rm = TRUE)#
#
		for(i in 1:length(missingPeptides)){#
			sub <- data.l[data.l$FEATURE == missingPeptides[i], ]#
			t <- tapply(sub$ABUNDANCE, sub$GROUP, function(x) sum(x > 0, na.rm = TRUE))#
			missingConds <- names(t)[which(t == 0 | is.na(t))]		#
			data.l[data.l$FEATURE %in% missingPeptides[i] & data.l$GROUP %in% missingConds, ]$ABUNDANCE <- imputeValue#
		}#
#
		if(length(missingPeptides) > 0){#
			number.missing <- length(missingPeptides)#
			message(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = ""))	#
			processout<-rbind(processout,c(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = "")))#
			write.table(processout, file=finalfile, row.names=FALSE)	#
		}#
	}#
#	data<-rbindlist(list(data.l,data.h))#
	data<-rbind(data.l,data.h)#
#
}#
## even though it is not the case, user can do with no interaction ( no else command)#
## #
if ( missing.action == "remove" ){#
	data<-data[-which(data$FEATURE %in% missingPeptides),]#
#
	message("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model.")#
	processout<-rbind(processout,c("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
#
}#
## for assigning interference#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
#
###
	processout<-rbind(processout,c(paste("missing.action : ",missing.action," - okay",sep="")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
###==================================================#
### start to analyze by protein ID#
#
	### need original group information#
	origGroup<-unique(data$GROUP_ORIGINAL)#
for (i in 1:nlevels(data$PROTEIN)){#
#
	sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)#
	## need to assigning whether interaction term is included or not#
	remove.interaction<-interference#
if ( missing.action == "nointeraction" & missing.results [ i ]){#
	remove.interaction = FALSE#
	message("** ",paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = ""))#
	processout<-rbind(processout,c(paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = "")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
}#
#
	message(paste("Testing a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")"))#
	if(singleFeature){#
		message("** Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted.")#
		processout<-rbind(processout,c(paste("Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		temp<-try(.fit.model.single(contrast.matrix,sub,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup),silent=TRUE)#
#
	}	#
	if(!singleFeature){#
#
# not sure it is correct and what it means#
#	noRunFeature<-.checkRunbyFeature(sub)#
#	if(noRunFeature) unbalanced=TRUE#
	temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)#
#
	}#
## fix(apr 16)#
	if(class(temp)=="try-error") {#
		message("*** error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.")#
		processout<-rbind(processout,c(paste("error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		tempresult<-list(result=NULL,valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
		for(k in 1:nrow(contrast.matrix)){	#
			tempresult$result<-rbind(tempresult$result, data.frame(Protein=levels(data$PROTEIN)[i],Label=row.names(contrast.matrix)[k], logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA))#
		}#
	}else{#
		tempresult<-temp#
	}#
#
## comparison result table#
#	out<-rbindlist(list(out,tempresult$result))#
	out<-rbind(out,tempresult$result)#
#
## for checking model assumptions#
## add residual and fitted after fitting the model#
	if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}#
	## order concerned#
#	residuals<-data.frame(temp$valueresid)#
#	fitted<-data.frame(temp$valuefitted)#
#	sub<-merge(sub,residuals,by="row.names",all=T)#
#	rownames(sub)<-sub$Row.names#
#	sub<-merge(sub, fitted, by="row.names",all=T)#
#	rownames(sub)<-data$Row.names#
#
#	dataafterfit<-rbindlist(list(dataafterfit,sub))#
	dataafterfit<-rbind(dataafterfit,sub)#
#
## save fitted model#
	outfitted<-c(outfitted, list(tempresult$fittedmodel))#
#
###
	processout<-rbind(processout,c(paste("Finished a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
} ### end protein loop#
#
###
	processout<-rbind(processout,c("Comparisons for all proteins are done.- okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
##### finalize result#
## need to FDR per comparison#
out.all<-NULL#
#
out$Label<-as.character(out$Label)#
for(i in 1:nrow(contrast.matrix)){#
	outsub<-out[out$Label==row.names(contrast.matrix)[i],]#
	outsub<-data.frame(outsub,adj.pvalue=p.adjust(outsub$pvalue,method="BH"))#
#	out.all<-rbindlist(list(out.all, outsub))#
	out.all<-rbind(out.all, outsub)#
#
}#
out.all$Label<-factor(out.all$Label)#
###
	processout<-rbind(processout,c("Adjust p-values per comparison are calculated - okay."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log2FC"#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log10FC"#
}#
#
	## change the format as data.frame#
	out.all<-data.frame(out.all)#
#
###
	processout<-rbind(processout,c("Group comparison is done. - okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
finalout<-list(ComparisonResult=out.all, ModelQC=dataafterfit, fittedmodel=outfitted)#
return(finalout)	#
#
}
?groupComparison
test2<-groupComparison(contrast.matrix=comparison, data=QuantData)
test2$ComparisonResult
test2$fittedmodel
names(test2)
test2<-groupComparison2(contrast.matrix=comparison, data=QuantData)
test2$ComparisonResult
names(test2)
test2$fittedmodel
?designSampleSize
designSampleSize(data=QuantData,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
designSampleSize2(data=test2$fittedmodel,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
test2$fittedmodel[[3]]<-NA
length(test2$fittedmodel)
test2$fittedmodel
i=3
data<-test2$fittedmodel
fit.full<-data[[i]]
fit.full
is.na(fit.full)
if(is.na(fit.full)) {#
					next#
				}else{#
					## get variance component#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}
sigma.error<-NULL
VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)
for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.na(fit.full)) {#
					next#
				}else{#
					## get variance component#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop
sigma.error<-NULL
VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)
data[[3]]
data[[3]]<-NULL
data[[3]]
data
data[[3]]<-NA
data
data[[3]]<-NULL
data
length(data)
data[[4]]<-"a"
data
length(data)
data[[5]]<-NULL
data
data[[6]]<-"b"
data
data[[7]]<-"error"
data
designSampleSize2<-function(data=data,labeled=TRUE,numSample=numSample,numPep=numPep,numTran=numTran,desiredFC=desiredFC,FDR=0.05,power=0.9,scopeOfBioReplication="restricted",interference=TRUE,equalFeatureVar=TRUE){#
#
	nrepeats=3#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile,header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - designSampleSize function"," "),ncol=1))#
	## check one TRUE or not#
	if( sum(isTRUE(numSample),isTRUE(numPep),isTRUE(numTran),isTRUE(power))!=1 ){#
		processout<-rbind(processout,c(paste("The required input - number of sample or features : Only one value should be TRUE. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("One of (numSample, numPep, numTran, power) needs to be TRUE")#
	}#
#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	## all input#
		processout<-rbind(processout,c(paste("number of sample = ",numSample,sep="")))#
		processout<-rbind(processout,c(paste("number of peptide per protein = ",numPep,sep="")))#
		processout<-rbind(processout,c(paste("number of transition per peptide = ", numTran,sep="")))#
		processout<-rbind(processout,c(paste("Desired fold change = ",paste(desiredFC,collapse=" - "),sep="")))#
		processout<-rbind(processout,c(paste("FDR = ",FDR,sep="")))#
		processout<-rbind(processout,c(paste("Power = ", power,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
	## for label-free experiment#
	if (!labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(fit.full=="error") {#
					next#
				}else{#
					## get variance component#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
#		VarComponent[is.na(VarComponent)]<-0	#
		## for label-free DDA, there are lots of missingness and lots of zero SE. So, remove NA SE.#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(!is.na(VarComponent[,"GroupBySubject"]))>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			if(sum(!is.na(VarComponent[,"Subject"]))>0){#
				median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
			}else{#
				median.sigma.subject<-0#
			}#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt(2*median.sigma.error/numPep/numTran/numSample+median.sigma.subject/numSample)#
   			 powerTemp<-seq(0,1,0.01)#
    		power<-NULL#
   			for(i in 1:length(t)){#
    			diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
    			min(abs(diff),na.rm=TRUE)#
    			power[i]<-powerTemp[order(abs(diff))][1]#
    		}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
    		####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
    		out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if (isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round((2*median.sigma.error/numPep/numTran+median.sigma.subject)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if (isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((2*median.sigma.error/numSample/numTran+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if (isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((2*median.sigma.error/numSample/numPep+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # when power is numeric#
	} ## label-free#
	## isotope labeled experiment#
	if (labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(fit.full=="error") {#
					next#
#
				}else{#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
		## label-based case, few of NA SE.#
		VarComponent[is.na(VarComponent)]<-0	#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(VarComponent[,"GroupBySubject"])>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt((4*median.sigma.error/numPep/numTran/numSample)+(2*median.sigma.subject/numSample))#
			powerTemp<-seq(0,1,0.01)#
			power<-NULL#
			for(i in 1:length(t)){#
				diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
				min(abs(diff),na.rm=TRUE)#
				power[i]<-powerTemp[order(abs(diff))][1]#
			}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
        	####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
  			out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if(isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round(((4*median.sigma.error/numPep/numTran)+(2*median.sigma.subject))/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+(2*median.sigma.subject/numSample))/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if(isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((4*median.sigma.error/numSample/numTran+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if(isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((4*median.sigma.error/numSample/numPep+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # power is numeric#
	} ## label-based#
}
groupComparison2<-function(contrast.matrix=contrast.matrix,data=data,labeled=TRUE, scopeOfBioReplication="restricted", scopeOfTechReplication="expanded", interference=TRUE,equalFeatureVar=TRUE,missing.action = "nointeraction"){#
#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile, header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - groupComparison function"," "),ncol=1))#
	## check input is correct#
	## data format#
	rawinput<-c("ProteinName","PeptideSequence","PrecursorCharge","FragmentIon","ProductCharge","IsotopeLabelType","Condition","BioReplicate","Run","Intensity")#
	if(length(setdiff(toupper(rawinput),toupper(colnames(data))))==0){#
		processout<-rbind(processout,c(paste("The required input - data : did not process from dataProcess function. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("Please use 'dataProcess' first. Then use output of dataProcess function as input in groupComparison.")#
	}#
	## contrast. matrix#
	if(ncol(contrast.matrix)!=length(unique(data$GROUP_ORIGINAL))){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: the number of column and the number of group are not the same. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("Please check contrast matrix. The number of group in data set is different with columns of contrast.matrix.")#
	}#
	# check whether row.names of contrast.matrix.sub exists or not#
	if(sum(is.null(row.names(contrast.matrix)))>0){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: need row names of contrast.matrix . - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("No row.names of comparison exist.\n")#
	}#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(sum(unique(data$LABEL) %in% "H")==0 & labeled==TRUE){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. labeled should be 'FALSE'. Therefore now use labeled=FALSE")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 message("Dataset is based on label-free experiment. MSstats will use \"labeled\"=FALSE.")#
		 labeled<-FALSE#
	}#
	## other option value#
	if(!(scopeOfTechReplication=="restricted" | scopeOfTechReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfTechReplication : 'scopeOfTechReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfTechReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	}#
	if(!(scopeOfBioReplication=="restricted" | scopeOfBioReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfBioReplication : 'scopeOfBioReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfBioReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	} #
	if(!(interference==TRUE | interference==FALSE) | !is.logical(interference)){#
		processout<-rbind(processout,c(paste("The required input - interference : 'interference' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'interference' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(!(equalFeatureVar==TRUE | equalFeatureVar==FALSE) | !is.logical(equalFeatureVar)){#
		processout<-rbind(processout,c(paste("The required input - equalFeatureVar : 'equalFeatureVar' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("'equalFeatureVar' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(equalFeatureVar==FALSE & (scopeOfBioReplication=="expanded" | scopeOfTechReplication=="expanded")){#
		message("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication.")#
		processout<-rbind(processout,c("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication."))#
		write.table(processout, file=finalfile, row.names=FALSE)#
	}#
	if(!(missing.action %in% c("nointeraction", "impute", "remove"))){#
		processout<-rbind(processout,c(paste("The required input - missing.action : 'missing.action' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'missing.action' must be one of \"nointeraction\", \"impute\", or \"remove\".")#
	}#
#
	## all input#
		processout<-rbind(processout,c(paste("labeled = ",labeled,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfBioReplication = ",scopeOfBioReplication,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfTechReplication = ", scopeOfTechReplication,sep="")))#
		processout<-rbind(processout,c(paste("interference = ",interference,sep="")))#
		processout<-rbind(processout,c(paste("equalFeatureVar = ",equalFeatureVar,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
## check whether case-control(FALSE) or time-course(TRUE)#
repeated<-.checkRepeated(data)#
#
	if(repeated){ #
		processout<-rbind(processout,c(paste("Time course design of experiment - okay")))#
	}else{#
		processout<-rbind(processout,c(paste("Case control design of experiment - okay")))#
#
	}#
	write.table(processout, file=finalfile, row.names=FALSE)#
## since case-control(FALSE) with fixed subject and random run will fit the crossed model#
# we need to set subject_original to non-unique#
#
if(repeated==FALSE&scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
	test<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	test<- test[with(test, order(GROUP_ORIGINAL,SUBJECT_ORIGINAL)),]#
	test$GROUP_ORIGINAL<-factor(test$GROUP_ORIGINAL)#
	test1<-as.matrix(xtabs(~test[,1]))#
	test$SUBJECT_ORIGINAL_NOUNIQUE<-as.numeric(unlist(apply(test1,1,function(x) seq(x))))#
#
	data$SUBJECT_ORIGINAL<-as.character(data$SUBJECT_ORIGINAL)#
#
	for (i in 1:length(unique(test$SUBJECT_ORIGINAL_NOUNIQUE))){#
		list<-test$SUBJECT_ORIGINAL[test$SUBJECT_ORIGINAL_NOUNIQUE==i]#
		data$SUBJECT_ORIGINAL[data$SUBJECT_ORIGINAL%in%list]<-i	#
	}#
#
	data$SUBJECT_ORIGINAL<-factor(data$SUBJECT_ORIGINAL)#
}#
data$PROTEIN<-factor(data$PROTEIN)	#
#
## for final result report#
out<-NULL#
outsummary<-NULL#
outfitted<-NULL#
dataafterfit<-NULL#
#
##################################
### how to handle missingness for endogenous#
#
data.l<-data[data$LABEL=="L",]#
data.h<-data[data$LABEL=="H",]#
#
missingPeptides<-.checkMissFeature(data.l)#
#
protein.list = tapply ( data.l$FEATURE, data.l$PROTEIN, function ( x ) unique ( as.character ( x ) ) )#
#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
## Impute for missing endogenous intensity#
if ( missing.action == "impute" ) { #
	if(length(missingPeptides) > 0){#
		dataBySample <- tapply(data.l$ABUNDANCE, list(data.l$SUBJECT_ORIGINAL, data.l$FEATURE), function(x) min(x, na.rm = TRUE))#
		dataBySample <- dataBySample[!(apply(dataBySample, 1, function(x) sum(is.na(x))) == ncol(dataBySample)), ]#
#
		if(!is.numeric(dataBySample)){ ## only one subject#
			minValuePerSample <- apply(dataBySample, 1, function(x) min(x, na.rm = TRUE))#
		}else{#
			minValuePerSample<-min(dataBySample, na.rm=TRUE)#
		}#
		imputeValue <- mean(minValuePerSample[!is.infinite(minValuePerSample)], na.rm = TRUE)#
#
		for(i in 1:length(missingPeptides)){#
			sub <- data.l[data.l$FEATURE == missingPeptides[i], ]#
			t <- tapply(sub$ABUNDANCE, sub$GROUP, function(x) sum(x > 0, na.rm = TRUE))#
			missingConds <- names(t)[which(t == 0 | is.na(t))]		#
			data.l[data.l$FEATURE %in% missingPeptides[i] & data.l$GROUP %in% missingConds, ]$ABUNDANCE <- imputeValue#
		}#
#
		if(length(missingPeptides) > 0){#
			number.missing <- length(missingPeptides)#
			message(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = ""))	#
			processout<-rbind(processout,c(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = "")))#
			write.table(processout, file=finalfile, row.names=FALSE)	#
		}#
	}#
#	data<-rbindlist(list(data.l,data.h))#
	data<-rbind(data.l,data.h)#
#
}#
## even though it is not the case, user can do with no interaction ( no else command)#
## #
if ( missing.action == "remove" ){#
	data<-data[-which(data$FEATURE %in% missingPeptides),]#
#
	message("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model.")#
	processout<-rbind(processout,c("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
#
}#
## for assigning interference#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
#
###
	processout<-rbind(processout,c(paste("missing.action : ",missing.action," - okay",sep="")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
###==================================================#
### start to analyze by protein ID#
#
	### need original group information#
	origGroup<-unique(data$GROUP_ORIGINAL)#
for (i in 1:nlevels(data$PROTEIN)){#
#
	sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)#
	## need to assigning whether interaction term is included or not#
	remove.interaction<-interference#
if ( missing.action == "nointeraction" & missing.results [ i ]){#
	remove.interaction = FALSE#
	message("** ",paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = ""))#
	processout<-rbind(processout,c(paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = "")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
}#
#
	message(paste("Testing a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")"))#
	if(singleFeature){#
		message("** Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted.")#
		processout<-rbind(processout,c(paste("Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		temp<-try(.fit.model.single(contrast.matrix,sub,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup),silent=TRUE)#
#
	}	#
	if(!singleFeature){#
#
# not sure it is correct and what it means#
#	noRunFeature<-.checkRunbyFeature(sub)#
#	if(noRunFeature) unbalanced=TRUE#
	temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)#
#
	}#
## fix(apr 16)#
	if(class(temp)=="try-error") {#
		message("*** error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.")#
		processout<-rbind(processout,c(paste("error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		tempresult<-list(result=NULL,valueresid=NULL, valuefitted=NULL, fittedmodel="error")#
		for(k in 1:nrow(contrast.matrix)){	#
			tempresult$result<-rbind(tempresult$result, data.frame(Protein=levels(data$PROTEIN)[i],Label=row.names(contrast.matrix)[k], logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA))#
		}#
	}else{#
		tempresult<-temp#
	}#
#
## comparison result table#
#	out<-rbindlist(list(out,tempresult$result))#
	out<-rbind(out,tempresult$result)#
#
## for checking model assumptions#
## add residual and fitted after fitting the model#
	if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}#
	## order concerned#
#	residuals<-data.frame(temp$valueresid)#
#	fitted<-data.frame(temp$valuefitted)#
#	sub<-merge(sub,residuals,by="row.names",all=T)#
#	rownames(sub)<-sub$Row.names#
#	sub<-merge(sub, fitted, by="row.names",all=T)#
#	rownames(sub)<-data$Row.names#
#
#	dataafterfit<-rbindlist(list(dataafterfit,sub))#
	dataafterfit<-rbind(dataafterfit,sub)#
#
## save fitted model#
	outfitted<-c(outfitted, list(tempresult$fittedmodel))#
#
###
	processout<-rbind(processout,c(paste("Finished a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
} ### end protein loop#
#
###
	processout<-rbind(processout,c("Comparisons for all proteins are done.- okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
##### finalize result#
## need to FDR per comparison#
out.all<-NULL#
#
out$Label<-as.character(out$Label)#
for(i in 1:nrow(contrast.matrix)){#
	outsub<-out[out$Label==row.names(contrast.matrix)[i],]#
	outsub<-data.frame(outsub,adj.pvalue=p.adjust(outsub$pvalue,method="BH"))#
#	out.all<-rbindlist(list(out.all, outsub))#
	out.all<-rbind(out.all, outsub)#
#
}#
out.all$Label<-factor(out.all$Label)#
###
	processout<-rbind(processout,c("Adjust p-values per comparison are calculated - okay."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log2FC"#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log10FC"#
}#
#
	## change the format as data.frame#
	out.all<-data.frame(out.all)#
#
###
	processout<-rbind(processout,c("Group comparison is done. - okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
finalout<-list(ComparisonResult=out.all, ModelQC=dataafterfit, fittedmodel=outfitted)#
return(finalout)	#
#
}
test2<-groupComparison2(contrast.matrix=comparison, data=QuantData)
data<-test2$fittedmodel
data
?designSampleSize
designSampleSize2(data=test2$fittedmodel,labeled=TRUE,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
data<-test2$fittedmodel[[2]]
fit.full<-test2$fittedmodel[[2]]
fit.full=="error"
fit.full
class(fit.full)
names(fit.full)
attributes(fit.full)
groupComparison2<-function(contrast.matrix=contrast.matrix,data=data,labeled=TRUE, scopeOfBioReplication="restricted", scopeOfTechReplication="expanded", interference=TRUE,equalFeatureVar=TRUE,missing.action = "nointeraction"){#
#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile, header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - groupComparison function"," "),ncol=1))#
	## check input is correct#
	## data format#
	rawinput<-c("ProteinName","PeptideSequence","PrecursorCharge","FragmentIon","ProductCharge","IsotopeLabelType","Condition","BioReplicate","Run","Intensity")#
	if(length(setdiff(toupper(rawinput),toupper(colnames(data))))==0){#
		processout<-rbind(processout,c(paste("The required input - data : did not process from dataProcess function. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("Please use 'dataProcess' first. Then use output of dataProcess function as input in groupComparison.")#
	}#
	## contrast. matrix#
	if(ncol(contrast.matrix)!=length(unique(data$GROUP_ORIGINAL))){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: the number of column and the number of group are not the same. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("Please check contrast matrix. The number of group in data set is different with columns of contrast.matrix.")#
	}#
	# check whether row.names of contrast.matrix.sub exists or not#
	if(sum(is.null(row.names(contrast.matrix)))>0){#
		processout<-rbind(processout,c(paste("The required input - contrast.matrix: need row names of contrast.matrix . - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("No row.names of comparison exist.\n")#
	}#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(sum(unique(data$LABEL) %in% "H")==0 & labeled==TRUE){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. labeled should be 'FALSE'. Therefore now use labeled=FALSE")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 message("Dataset is based on label-free experiment. MSstats will use \"labeled\"=FALSE.")#
		 labeled<-FALSE#
	}#
	## other option value#
	if(!(scopeOfTechReplication=="restricted" | scopeOfTechReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfTechReplication : 'scopeOfTechReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfTechReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	}#
	if(!(scopeOfBioReplication=="restricted" | scopeOfBioReplication=="expanded")){#
		processout<-rbind(processout,c(paste("The required input - scopeOfBioReplication : 'scopeOfBioReplication' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		stop("'scopeOfBioReplication' must be one of \"restricted\" or \"expanded\".#
	")#
	} #
	if(!(interference==TRUE | interference==FALSE) | !is.logical(interference)){#
		processout<-rbind(processout,c(paste("The required input - interference : 'interference' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'interference' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(!(equalFeatureVar==TRUE | equalFeatureVar==FALSE) | !is.logical(equalFeatureVar)){#
		processout<-rbind(processout,c(paste("The required input - equalFeatureVar : 'equalFeatureVar' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		stop("'equalFeatureVar' must be one of TRUE or FALSE as a logical value.")#
	}#
	if(equalFeatureVar==FALSE & (scopeOfBioReplication=="expanded" | scopeOfTechReplication=="expanded")){#
		message("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication.")#
		processout<-rbind(processout,c("* Heterogeneous variation among intensities from different features (equalFeatureVar=FALSE) can be implemented only with restricted scope of replication. The result with expanded scope of replication will be implemented with equal variation of error among features. If you want to account for unequal variation of error for different peptide feature, please use restricted scope of both replication."))#
		write.table(processout, file=finalfile, row.names=FALSE)#
	}#
	if(!(missing.action %in% c("nointeraction", "impute", "remove"))){#
		processout<-rbind(processout,c(paste("The required input - missing.action : 'missing.action' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'missing.action' must be one of \"nointeraction\", \"impute\", or \"remove\".")#
	}#
#
	## all input#
		processout<-rbind(processout,c(paste("labeled = ",labeled,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfBioReplication = ",scopeOfBioReplication,sep="")))#
		processout<-rbind(processout,c(paste("scopeOfTechReplication = ", scopeOfTechReplication,sep="")))#
		processout<-rbind(processout,c(paste("interference = ",interference,sep="")))#
		processout<-rbind(processout,c(paste("equalFeatureVar = ",equalFeatureVar,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
## check whether case-control(FALSE) or time-course(TRUE)#
repeated<-.checkRepeated(data)#
#
	if(repeated){ #
		processout<-rbind(processout,c(paste("Time course design of experiment - okay")))#
	}else{#
		processout<-rbind(processout,c(paste("Case control design of experiment - okay")))#
#
	}#
	write.table(processout, file=finalfile, row.names=FALSE)#
## since case-control(FALSE) with fixed subject and random run will fit the crossed model#
# we need to set subject_original to non-unique#
#
if(repeated==FALSE&scopeOfBioReplication=="restricted"&scopeOfTechReplication=="expanded"){#
	test<-unique(data[,c("GROUP_ORIGINAL","SUBJECT_ORIGINAL")])#
	test<- test[with(test, order(GROUP_ORIGINAL,SUBJECT_ORIGINAL)),]#
	test$GROUP_ORIGINAL<-factor(test$GROUP_ORIGINAL)#
	test1<-as.matrix(xtabs(~test[,1]))#
	test$SUBJECT_ORIGINAL_NOUNIQUE<-as.numeric(unlist(apply(test1,1,function(x) seq(x))))#
#
	data$SUBJECT_ORIGINAL<-as.character(data$SUBJECT_ORIGINAL)#
#
	for (i in 1:length(unique(test$SUBJECT_ORIGINAL_NOUNIQUE))){#
		list<-test$SUBJECT_ORIGINAL[test$SUBJECT_ORIGINAL_NOUNIQUE==i]#
		data$SUBJECT_ORIGINAL[data$SUBJECT_ORIGINAL%in%list]<-i	#
	}#
#
	data$SUBJECT_ORIGINAL<-factor(data$SUBJECT_ORIGINAL)#
}#
data$PROTEIN<-factor(data$PROTEIN)	#
#
## for final result report#
out<-NULL#
outsummary<-NULL#
outfitted<-NULL#
dataafterfit<-NULL#
#
##################################
### how to handle missingness for endogenous#
#
data.l<-data[data$LABEL=="L",]#
data.h<-data[data$LABEL=="H",]#
#
missingPeptides<-.checkMissFeature(data.l)#
#
protein.list = tapply ( data.l$FEATURE, data.l$PROTEIN, function ( x ) unique ( as.character ( x ) ) )#
#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
## Impute for missing endogenous intensity#
if ( missing.action == "impute" ) { #
	if(length(missingPeptides) > 0){#
		dataBySample <- tapply(data.l$ABUNDANCE, list(data.l$SUBJECT_ORIGINAL, data.l$FEATURE), function(x) min(x, na.rm = TRUE))#
		dataBySample <- dataBySample[!(apply(dataBySample, 1, function(x) sum(is.na(x))) == ncol(dataBySample)), ]#
#
		if(!is.numeric(dataBySample)){ ## only one subject#
			minValuePerSample <- apply(dataBySample, 1, function(x) min(x, na.rm = TRUE))#
		}else{#
			minValuePerSample<-min(dataBySample, na.rm=TRUE)#
		}#
		imputeValue <- mean(minValuePerSample[!is.infinite(minValuePerSample)], na.rm = TRUE)#
#
		for(i in 1:length(missingPeptides)){#
			sub <- data.l[data.l$FEATURE == missingPeptides[i], ]#
			t <- tapply(sub$ABUNDANCE, sub$GROUP, function(x) sum(x > 0, na.rm = TRUE))#
			missingConds <- names(t)[which(t == 0 | is.na(t))]		#
			data.l[data.l$FEATURE %in% missingPeptides[i] & data.l$GROUP %in% missingConds, ]$ABUNDANCE <- imputeValue#
		}#
#
		if(length(missingPeptides) > 0){#
			number.missing <- length(missingPeptides)#
			message(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = ""))	#
			processout<-rbind(processout,c(paste("* There are ", number.missing, " features (", paste(missingPeptides, collapse = ", "), ") that are missing intensities for an entire condition.  Intensities in these conditions have been imputed with the minimum intensity across all samples.", sep = "")))#
			write.table(processout, file=finalfile, row.names=FALSE)	#
		}#
	}#
#	data<-rbindlist(list(data.l,data.h))#
	data<-rbind(data.l,data.h)#
#
}#
## even though it is not the case, user can do with no interaction ( no else command)#
## #
if ( missing.action == "remove" ){#
	data<-data[-which(data$FEATURE %in% missingPeptides),]#
#
	message("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model.")#
	processout<-rbind(processout,c("* The features that are missing intensities for an entire condition in Protein will be removed for fitting the model."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
#
}#
## for assigning interference#
missing.results = sapply ( protein.list, function ( x ) any ( x %in% missingPeptides ) )#
#
###
	processout<-rbind(processout,c(paste("missing.action : ",missing.action," - okay",sep="")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
###==================================================#
### start to analyze by protein ID#
#
	### need original group information#
	origGroup<-unique(data$GROUP_ORIGINAL)#
for (i in 1:nlevels(data$PROTEIN)){#
#
	sub<-data[data$PROTEIN==levels(data$PROTEIN)[i],]#
#
	# it is important to remove NA first, before we have the correct structure for each factor#
	sub<-sub[!is.na(sub$ABUNDANCE),]#
#
	sub$GROUP<-factor(sub$GROUP)#
	sub$SUBJECT<-factor(sub$SUBJECT)#
	sub$GROUP_ORIGINAL<-factor(sub$GROUP_ORIGINAL)	#
	sub$SUBJECT_ORIGINAL<-factor(sub$SUBJECT_ORIGINAL)#
	sub$SUBJECT_NESTED<-factor(sub$SUBJECT_NESTED)#
	sub$FEATURE<-factor(sub$FEATURE)	#
	sub$RUN<-factor(sub$RUN)#
	singleFeature<-.checkSingleFeature(sub)#
	singleSubject<-.checkSingleSubject(sub)#
	TechReplicate<-.checkTechReplicate(sub) ## use for label-free model#
#
	MissGroupByFeature<-.checkMissGroupByFeature(sub)#
	MissRunByFeature<-.checkMissRunByFeature(sub)#
	MissSubjectByGroup<-.checkRunbyFeature(sub)#
	UnequalSubject<-.checkUnequalSubject(sub)#
	## need to assigning whether interaction term is included or not#
	remove.interaction<-interference#
if ( missing.action == "nointeraction" & missing.results [ i ]){#
	remove.interaction = FALSE#
	message("** ",paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = ""))#
	processout<-rbind(processout,c(paste(levels(data$PROTEIN)[i]," has some features that are missing intensities for an entire condition in Protein, The additive model (without interaction) will be fitted.", sep = "")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
}#
#
	message(paste("Testing a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")"))#
	if(singleFeature){#
		message("** Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted.")#
		processout<-rbind(processout,c(paste("Protein ",levels(data$PROTEIN)[i]," has only single transition, the simplied model is fitted", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		temp<-try(.fit.model.single(contrast.matrix,sub,labeled,scopeOfTechReplication,scopeOfBioReplication,TechReplicate,repeated,origGroup),silent=TRUE)#
#
	}	#
	if(!singleFeature){#
#
# not sure it is correct and what it means#
#	noRunFeature<-.checkRunbyFeature(sub)#
#	if(noRunFeature) unbalanced=TRUE#
	temp<-try(.fit.model(contrast.matrix,sub,labeled, scopeOfBioReplication,scopeOfTechReplication,interference=remove.interaction,repeated,MissGroupByFeature,MissRunByFeature,UnequalSubject,singleSubject,TechReplicate,equalFeatureVar,origGroup),silent=TRUE)#
#
	}#
## fix(apr 16)#
	if(class(temp)=="try-error") {#
		message("*** error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.")#
		processout<-rbind(processout,c(paste("error : can't analyze ", levels(data$PROTEIN)[i], " for comparison.", sep = "")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		tempresult<-list(result=NULL,valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
		for(k in 1:nrow(contrast.matrix)){	#
			tempresult$result<-rbind(tempresult$result, data.frame(Protein=levels(data$PROTEIN)[i],Label=row.names(contrast.matrix)[k], logFC=NA,SE=NA,Tvalue=NA,DF=NA,pvalue=NA))#
		}#
	}else{#
		tempresult<-temp#
	}#
#
## comparison result table#
#	out<-rbindlist(list(out,tempresult$result))#
	out<-rbind(out,tempresult$result)#
#
## for checking model assumptions#
## add residual and fitted after fitting the model#
	if(class(temp)=="try-error") {#
		if(nrow(sub)!=0){#
			sub$residuals<-NA#
			sub$fitted<-NA#
		}#
	}else{#
		sub$residuals<-temp$valueresid#
		sub$fitted<-temp$valuefitted#
	}#
	## order concerned#
#	residuals<-data.frame(temp$valueresid)#
#	fitted<-data.frame(temp$valuefitted)#
#	sub<-merge(sub,residuals,by="row.names",all=T)#
#	rownames(sub)<-sub$Row.names#
#	sub<-merge(sub, fitted, by="row.names",all=T)#
#	rownames(sub)<-data$Row.names#
#
#	dataafterfit<-rbindlist(list(dataafterfit,sub))#
	dataafterfit<-rbind(dataafterfit,sub)#
#
## save fitted model#
	outfitted<-c(outfitted, list(tempresult$fittedmodel))#
#
###
	processout<-rbind(processout,c(paste("Finished a comparison for protein ",unique(sub$PROTEIN), "(",i," of ",length(unique(data$PROTEIN)),")")))#
	write.table(processout, file=finalfile, row.names=FALSE)#
} ### end protein loop#
#
###
	processout<-rbind(processout,c("Comparisons for all proteins are done.- okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
##### finalize result#
## need to FDR per comparison#
out.all<-NULL#
#
out$Label<-as.character(out$Label)#
for(i in 1:nrow(contrast.matrix)){#
	outsub<-out[out$Label==row.names(contrast.matrix)[i],]#
	outsub<-data.frame(outsub,adj.pvalue=p.adjust(outsub$pvalue,method="BH"))#
#	out.all<-rbindlist(list(out.all, outsub))#
	out.all<-rbind(out.all, outsub)#
#
}#
out.all$Label<-factor(out.all$Label)#
###
	processout<-rbind(processout,c("Adjust p-values per comparison are calculated - okay."))#
	write.table(processout, file=finalfile, row.names=FALSE)#
temp<-data[!is.na(data[,"ABUNDANCE"]),]#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])<#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log2FC"#
}#
#
if(abs(log2(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])>#
abs(log10(temp[1,"INTENSITY"])-temp[1,"ABUNDANCE"])){#
	colnames(out.all)[3]<-"log10FC"#
}#
#
	## change the format as data.frame#
	out.all<-data.frame(out.all)#
#
###
	processout<-rbind(processout,c("Group comparison is done. - okay"))#
	write.table(processout, file=finalfile, row.names=FALSE)#
finalout<-list(ComparisonResult=out.all, ModelQC=dataafterfit, fittedmodel=outfitted)#
return(finalout)	#
#
}
designSampleSize2<-function(data=data,labeled=TRUE,numSample=numSample,numPep=numPep,numTran=numTran,desiredFC=desiredFC,FDR=0.05,power=0.9,scopeOfBioReplication="restricted",interference=TRUE,equalFeatureVar=TRUE){#
#
	nrepeats=3#
	## save process output in each step#
	allfiles<-list.files()#
	filenaming<-"msstats"#
	if(length(grep(filenaming,allfiles))==0){#
		finalfile<-"msstats.log"#
		processout<-NULL#
	}else{#
		num<-0#
		finalfile<-"msstats.log"#
#
		while(is.element(finalfile,allfiles)){#
			num<-num+1#
			lastfilename<-finalfile ## in order to rea#
			finalfile<-paste(paste(filenaming,num,sep="-"),".log",sep="")#
		}#
		finalfile<-lastfilename#
		processout<-as.matrix(read.table(finalfile,header=T, sep="\t"))#
	}#
	processout<-rbind(processout,as.matrix(c(" "," ","MSstats - designSampleSize function"," "),ncol=1))#
	## check one TRUE or not#
	if( sum(isTRUE(numSample),isTRUE(numPep),isTRUE(numTran),isTRUE(power))!=1 ){#
		processout<-rbind(processout,c(paste("The required input - number of sample or features : Only one value should be TRUE. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("One of (numSample, numPep, numTran, power) needs to be TRUE")#
	}#
#
	## labeled value#
	if(!(labeled==TRUE | labeled==FALSE) | !is.logical(labeled)){#
		processout<-rbind(processout,c(paste("The required input - labeled : 'labeled' value is wrong. - stop")))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
		 stop("'labeled' must be one of TRUE or FALSE as a logical value.")#
	}#
	## all input#
		processout<-rbind(processout,c(paste("number of sample = ",numSample,sep="")))#
		processout<-rbind(processout,c(paste("number of peptide per protein = ",numPep,sep="")))#
		processout<-rbind(processout,c(paste("number of transition per peptide = ", numTran,sep="")))#
		processout<-rbind(processout,c(paste("Desired fold change = ",paste(desiredFC,collapse=" - "),sep="")))#
		processout<-rbind(processout,c(paste("FDR = ",FDR,sep="")))#
		processout<-rbind(processout,c(paste("Power = ", power,sep="")))#
#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
	## for label-free experiment#
	if (!labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.null(fit.full)) {#
					## !!!!! but if we have NULL for last protein?#
					next#
				}else{#
					## get variance component#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
#		VarComponent[is.na(VarComponent)]<-0	#
		## for label-free DDA, there are lots of missingness and lots of zero SE. So, remove NA SE.#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(!is.na(VarComponent[,"GroupBySubject"]))>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			if(sum(!is.na(VarComponent[,"Subject"]))>0){#
				median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
			}else{#
				median.sigma.subject<-0#
			}#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt(2*median.sigma.error/numPep/numTran/numSample+median.sigma.subject/numSample)#
   			 powerTemp<-seq(0,1,0.01)#
    		power<-NULL#
   			for(i in 1:length(t)){#
    			diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
    			min(abs(diff),na.rm=TRUE)#
    			power[i]<-powerTemp[order(abs(diff))][1]#
    		}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
    		####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
    		out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if (isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round((2*median.sigma.error/numPep/numTran+median.sigma.subject)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if (isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((2*median.sigma.error/numSample/numTran+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if (isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((2*median.sigma.error/numSample/numPep+median.sigma.subject/numSample)/aa,0)#
				CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # when power is numeric#
	} ## label-free#
	## isotope labeled experiment#
	if (labeled){#
		sigma.error<-NULL	#
		VarComponent<-data.frame(Protein=seq(1,length(data)),Error=NA,Subject=NA,GroupBySubject=NA)#
#
		for (i in 1:length(data)){#
			# note: when run is fixed, we can obtain the same variance of error for both case-control and time course studies.#
			fit.full<-data[[i]]#
#
				## if fit.full==NA (class(fit.full)=="try-error)#
				if(is.null(fit.full)) {#
					next#
#
				}else{#
#
					if(class(fit.full)!="mer"){#
						VarComponent[i,"Error"]<-summary(fit.full)$sigma^2#
					}else{#
						stddev <- c(sapply(VarCorr(fit.full), function(el) attr(el, "stddev")),attr(VarCorr(fit.full), "sc"))#
						VarComponent[i,"Error"]<-stddev[names(stddev)==""]^2#
						if(sum(names(stddev)%in%"SUBJECT_NESTED.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT_NESTED.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT.(Intercept)")>0){#
							VarComponent[i,"Subject"]<-stddev[names(stddev)=="SUBJECT.(Intercept)"]^2#
						}#
						if(sum(names(stddev)%in%"SUBJECT:GROUP.(Intercept)")>0){#
							VarComponent[i,"GroupBySubject"]<-stddev[names(stddev)=="SUBJECT:GROUP.(Intercept)"]^2#
						}#
					}#
				}#
		} ## end-loop#
#
		## label-based case, few of NA SE.#
		VarComponent[is.na(VarComponent)]<-0	#
		median.sigma.error<-median(VarComponent[,"Error"],na.rm=TRUE)#
		if(sum(VarComponent[,"GroupBySubject"])>0){#
			median.sigma.subject<-median(VarComponent[,"GroupBySubject"],na.rm=TRUE)#
		}else{#
			median.sigma.subject<-median(VarComponent[,"Subject"],na.rm=TRUE)#
		}#
		####
		processout<-rbind(processout,c("Calculated variance component. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
		### power calculation#
		if(isTRUE(power)){#
			delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
			desiredFC<-2^delta#
			m0_m1=99#
			t<-delta/sqrt((4*median.sigma.error/numPep/numTran/numSample)+(2*median.sigma.subject/numSample))#
			powerTemp<-seq(0,1,0.01)#
			power<-NULL#
			for(i in 1:length(t)){#
				diff<-qnorm(powerTemp)+qnorm(1-powerTemp*FDR/(1+(1-FDR)*m0_m1)/2)-t[i]#
				min(abs(diff),na.rm=TRUE)#
				power[i]<-powerTemp[order(abs(diff))][1]#
			}#
    		CV<-round((2*median.sigma.error/(numSample*numPep*numTran)+median.sigma.subject/numSample)/desiredFC,3)#
        	####
		processout<-rbind(processout,c("Power is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
  			out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power=power,CV)#
    		return(out)#
    	}#
#
		if(is.numeric(power)){#
			# Large portion of proteins are not changing#
			m0_m1=99 ## it means m0/m1=99, m0/(m0+m1)=0.99#
			alpha<-power*FDR/(1+(1-FDR)*m0_m1)#
#
			### Num Sample calculation#
			if(isTRUE(numSample)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numSample<-round(((4*median.sigma.error/numPep/numTran)+(2*median.sigma.subject))/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+(2*median.sigma.subject/numSample))/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of sample is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Peptide calculation#
			if(isTRUE(numPep)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numPep<-round((4*median.sigma.error/numSample/numTran+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of peptide per protein is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
#
			### Num Transition calculation#
			if(isTRUE(numTran)){#
				delta<-log2(seq(desiredFC[1],desiredFC[2],0.025))#
				desiredFC<-2^delta#
				z_alpha<-qnorm(1-alpha/2)#
				z_beta<-qnorm(power)#
				aa<-(delta/(z_alpha+z_beta))^2#
				numTran<-round((4*median.sigma.error/numSample/numPep+2*median.sigma.subject/numSample)/aa,0)#
				CV<-round((4*median.sigma.error/(numSample*numPep*numTran)+2*median.sigma.subject/numSample)/desiredFC,3)#
				####
		processout<-rbind(processout,c("The number of transition per peptide is calculated. - okay"))#
		write.table(processout, file=finalfile, row.names=FALSE)#
#
				out<-data.frame(desiredFC,numSample,numPep,numTran,FDR,power,CV)#
				return(out)#
			}#
		} # power is numeric#
	} ## label-based#
}
test2<-groupComparison2(contrast.matrix=comparison, data=QuantData)
test2$fittedmodel
designSampleSize2(data=test2$fittedmodel,labeled=TRUE,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
designSampleSize(data=QuantDat,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
designSampleSize(data=QuantData,numSample=TRUE,numPep=3,numTran=4,#
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
